
/usr/include (root) [4] /bin/sh
# for file in *.h;
> do
> echo "$file";
> cat $file;
> done

M_DEFS.h
/*
   COPYRIGHT (c) 1985 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)M_DEFS.h     1.2 91/04/08";
*/

/*  these are the symbolic definitions for the standard messages
 *  available through printm
 */

#define M_CANTOPEN      1000501L        /*  can't open file %s          */
#define M_CANTCLOSE     1000502L        /*  can't close file %s         */
#define M_CANTSTAT      1000503L        /*  can't stat file %s          */
#define M_CANTCREATE    1000504L        /*  can't create file %s        */
#define M_CANTFIND      1000505L        /*  can't find file %s          */
#define M_CANTREAD      1000506L        /*  can't read file %s          */
#define M_CANTWRITE     1000507L        /*  can't write  file %s        */
#define M_CANTEXEC      1000508L        /*  can't exec program %s       */
#define M_CANTCOPY      1000509L        /*  can't copy file %s          */

#define M_NAME2LONG     1000510L        /*  file name too long; %s      */
#define M_CANTCHDIR     1000511L        /*  can't chdir to %s           */
#define M_CANTLINK      1000512L        /*  can't link to file %s       */
#define M_CANTCMOD      1000513L        /*  can't chmod on file %s      */
#define M_INVALDARG     1000514L        /*  invalid argument %s         */
#define M_NOMEMORY      1000515L        /*  no more memory              */
#define M_ILLOPT        1000516L        /*  option %c is illegal        */
#define M_ILLSTR        1000517L        /*  option %s is illegal        */

#define M_READERR       1000520L        /*  read error on file %s       */
#define M_WRITERR       1000521L        /*  write error on file %s      */
#define M_SEEKERR       1000522L        /*  seek error on file %s       */
#define M_CANTCOWN      1000523L        /*  can't chown on file %s      */
#define M_CANTMKNOD     1000524L        /*  can't mknod for file %s     */
#define M_CANTFORK      1000525L        /*  can't fork                  */
#define M_CANTSYMLINK 1000526L  /* can't create symlink %s */

#define M_PERROR        1000526L        /*  same as perror sys call     */


#define M_INFO          0
#define M_WARN          1
#define M_ERRO          2
#define M_HALT          3
a.out.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)a.out.h      1.2 93/02/05";
*/
/*      @(#)a.out.h     2.4     */

#include <nlist.h>      /* included for all machines */

#if u3b || vax || u3b5 || m68k

 /*             COMMON OBJECT FILE FORMAT



        File Organization:

        _______________________________________________    INCLUDE FILE
        |_______________HEADER_DATA___________________|
        |                                             |
        |       File Header                           |    "filehdr.h"
        |.............................................|
        |                                             |
        |       Auxilliary Header Information         |    "aouthdr.h"
        |                                             |
        |_____________________________________________|
        |                                             |
        |       ".text" section header                |    "scnhdr.h"
        |                                             |
        |.............................................|
        |                                             |
        |       ".data" section header                |       ''
        |                                             |
        |.............................................|
        |                                             |
        |       ".bss" section header                 |       ''
        |                                             |
        |_____________________________________________|
        |______________RAW_DATA_______________________|
        |                                             |
        |       ".text" section data (rounded to 4    |
        |                               bytes)        |
        |.............................................|
        |                                             |
        |       ".data" section data (rounded to 4    |
        |                               bytes)        |
        |_____________________________________________|
        |____________RELOCATION_DATA__________________|
        |                                             |
        |       ".text" section relocation data       |    "reloc.h"
        |                                             |
        |.............................................|
        |                                             |
        |       ".data" section relocation data       |       ''
        |                                             |
        |_____________________________________________|
        |__________LINE_NUMBER_DATA_(SDB)_____________|
        |                                             |
        |       ".text" section line numbers          |    "linenum.h"
        |                                             |
        |.............................................|
        |                                             |
        |       ".data" section line numbers          |       ''
        |                                             |
        |_____________________________________________|
        |________________SYMBOL_TABLE_________________|
        |                                             |
        |       ".text", ".data" and ".bss" section   |    "syms.h"
        |       symbols                               |    "storclass.h"
        |                                             |
        |_____________________________________________|
        |________________STRING_TABLE_________________|
        |                                             |
        |           long symbol names                 |
        |_____________________________________________|



                OBJECT FILE COMPONENTS

        HEADER FILES:
                        /usr/include/filehdr.h
                        /usr/include/aouthdr.h
                        /usr/include/scnhdr.h
                        /usr/include/reloc.h
                        /usr/include/linenum.h
                        /usr/include/syms.h
                        /usr/include/storclass.h

        STANDARD FILE:
                        /usr/include/a.out.h    "object file"
   */

#include "filehdr.h"
#include "aouthdr.h"
#include "scnhdr.h"
#include "reloc.h"
#include "linenum.h"
#include "syms.h"


#else /* u370 || pdp11 */


/*
 * Format of an a.out header
 */


struct  exec {  /* a.out header */
#if u370
        int             a_magic;        /* magic number */
        int             a_stamp;        /* The version of a.out */
                                        /* format of this file. */
#else
        short           a_magic;        /* magic number */
#endif
        unsigned        a_text;         /* size of text segment */
                                        /* in bytes             */
                                        /* padded out to next   */
                                        /* page boundary with   */
                                        /* binary zeros.        */
        unsigned        a_data;         /* size of initialized data */
                                        /* segment in bytes     */
                                        /* padded out to next   */
                                        /* page boundary with   */
                                        /* binary zeros.        */
        unsigned        a_bss;          /* Actual size of       */
                                        /* uninitialized data   */
                                        /* segment in bytes.    */
        unsigned        a_syms;         /* size of symbol table */
        unsigned        a_entry;        /* entry point */
#if u370
        unsigned        a_trsize;       /* size of text relocation */
        unsigned        a_drsize;       /* size of data relocation */
        unsigned        a_origin;       /* The origin to which  */
                                        /* this file was        */
                                        /* relocated.           */
        unsigned        a_actext;       /* The actual size of   */
                                        /* the text segment in  */
                                        /* bytes.               */
        unsigned        a_acdata;       /* The actual size of   */
                                        /* the data segment in  */
                                        /* bytes.               */
#endif
#if pdp11
        char            a_unused;       /* not used */
        unsigned char   a_hitext;       /* high order text bits */
        char            a_flag;         /* reloc info stripped */
        char            a_stamp;        /* environment stamp */
#endif
};

#define A_MAGIC1        0407            /* normal */
#define A_MAGIC0        0401            /* lpd (UNIX/RT) */
#define A_MAGIC2        0410            /* read-only text */
#define A_MAGIC3        0411            /* separated I&D */
#define A_MAGIC4        0405            /* overlay */
#define A_MAGIC5        0437            /* system overlay, separated I&D */
#define A_MAGIC6        0413            /* read-only text (aligned) */

#if u370
struct relocation_info {
          long  r_address;      /* relative to current segment */
          unsigned int
                r_symbolnum:24, /* if extern then symbol table */
                                /* ordinal (0, 1, 2, ...) else */
                                /* segment number (same as symbol types) */
                r_pcrel:1,      /* if so, segment offset has already */
                                /* been subtracted */
                r_length:2,     /* 0=byte, 1=word, 2=long */
                r_extern:1,     /* does not include value */
                                /* of symbol referenced */
                r_offset:1,     /* already includes origin */
                                /* of this segment (?) */
                r_pad:3;        /* nothing, yet */
};
#endif

/* in invocation of BADMAG macro, argument should not be a function. */

#define BADMAG(X) (X.a_magic != A_MAGIC1 &&\
                X.a_magic != A_MAGIC2 &&\
                X.a_magic != A_MAGIC3 &&\
                X.a_magic != A_MAGIC4 &&\
                X.a_magic != A_MAGIC5 &&\
                X.a_magic != A_MAGIC0)

        /* values for type flag */

#define N_UNDF  0       /* undefined */
#define N_TYPE  037
#define N_FN    037     /* file name symbol */

#if pdp11
#define N_ABS   01      /* absolute */
#define N_TEXT  02      /* text symbol */
#define N_DATA  03      /* data symbol */
#define N_BSS   04      /* bss symbol */
#define N_REG   024     /* register name */
#define N_EXT   040     /* external bit, or'ed in */
#define FORMAT  "%.6o"  /* to print a value */
#else
#define N_ABS   02      /* absolute */
#define N_TEXT  04      /* text */
#define N_DATA  06      /* data */
#define N_BSS   010
#define N_GSYM  0040    /* global sym: name,,type,0 */
#define N_FNAME 0042    /* procedure name (f77 kludge): name,,,0 */
#define N_FUN   0044    /* procedure: name,,linenumber,address */
#define N_STSYM 0046    /* static symbol: name,,type,address */
#define N_LCSYM 0050    /* .lcomm symbol: name,,type,address */
#define N_BSTR  0060    /* begin structure: name,,, */
#define N_RSYM  0100    /* register sym: name,,register,offset */
#define N_SLINE 0104    /* src line: ,,linenumber,address */
#define N_ESTR  0120    /* end structure: name,,, */
#define N_SSYM  0140    /* structure elt: name,,type,struct_offset */
#define N_SO    0144    /* source file name: name,,,address */
#define N_BENUM 0160    /* begin enum: name,,, */
#define N_LSYM  0200    /* local sym: name,,type,offset */
#define N_SOL   0204    /* #line source filename: name,,,address */
#define N_ENUM  0220    /* enum element: name,,,value */
#define N_PSYM  0240    /* parameter: name,,type,offset */
#define N_ENTRY 0244    /* alternate entry: name,,linenumber,address */
#define N_EENUM 0260    /* end enum: name,,, */
#define N_LBRAC 0300    /* left bracket: ,,nesting level,address */
#define N_RBRAC 0340    /* right bracket: ,,nesting level,address */
#define N_BCOMM 0342    /* begin common: name,,, */
#define N_ECOMM 0344    /* end common: name,,, */
#define N_ECOML 0350    /* end common (local name): ,,,address */
#define N_STRU  0374    /* 2nd entry for structure: str tag,,,length */
#define N_LENG  0376    /* second stab entry with length information */
#define N_EXT   01      /* external bit, or'ed in */
#define FORMAT  "%.8x"
#define STABTYPES 0340
#endif

#endif
alarm.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)alarm.h      1.1 86/05/15";
*/
/*      @(#)alarm.h     1.1     */
/*      3.0 SID #       1.1     */
/*
 * Hardware bits
 */
#define DTR   00002     /* Data Terminal Ready (primary alarm) */
#define R2S   00004     /* Request to Send (clear signal) */
#define RCT   00010     /* Secondary Transmit Data (auxiliary alarm) */
#define RCR   02000     /* Secondary Received Data (primary alarm status) */
#define C2S  020000     /* Clear to Send (auxiliary alarm status) */
#define RCHAR   063     /* The "reset character" */

/*
 * Function codes
 */
#define ALPRI   002000  /* Primary set, and test mask */
#define ALAUX   020000  /* Auxiliary set, and test mask */
#define ALTIME  000377  /* Timeout delay value mask */
#define ALSET   001000  /* Set timer delay */
#define ALRESET 004000  /* Restart watchdog timer */
#define ALCLEAR 010000  /* Clear all alarms */

struct sgtty alsgtty;

#define alrmopn(name)   (alfildes = open(name,2))
#define alrmclo()       close(alfildes)
#define alrm(cmd) \
        (&alsgtty->sg_flags = cmd, stty(alfildes, &alsgtty), &alsgtty->sg_flags)
aouthdr.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)aouthdr.h    1.1 86/05/15";
*/
/*      @(#)aouthdr.h   2.4 12/15/82    */

typedef struct aouthdr {
        short   magic;          /* see magic.h                          */
        short   vstamp;         /* version stamp                        */
        long    tsize;          /* text size in bytes, padded to FW
                                   bdry                                 */
        long    dsize;          /* initialized data "  "                */
        long    bsize;          /* uninitialized data "   "             */
#if u3b
        long    dum1;
        long    dum2;           /* pad to entry point   */
#endif
        long    entry;          /* entry pt.                            */
        long    text_start;     /* base of text used for this file      */
        long    data_start;     /* base of data used for this file      */
} AOUTHDR;
ar.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)ar.h 1.1 86/05/15";
*/
/*      @(#)ar.h        2.3     */
#if vax || u3b || u3b5 || m68k
/*              COMMON ARCHIVE FORMAT
*
*       ARCHIVE File Organization:
*       _______________________________________________
*       |__________ARCHIVE_MAGIC_STRING_______________|
*       |__________ARCHIVE_FILE_MEMBER_1______________|
*       |                                             |
*       |       Archive File Header "ar_hdr"          |
*       |.............................................|
*       |       Member Contents                       |
*       |               1. External symbol directory  |
*       |               2. Text file                  |
*       |_____________________________________________|
*       |________ARCHIVE_FILE_MEMBER_2________________|
*       |               "ar_hdr"                      |
*       |.............................................|
*       |       Member Contents (.o or text file)     |
*       |_____________________________________________|
*       |       .               .               .     |
*       |       .               .               .     |
*       |       .               .               .     |
*       |_____________________________________________|
*       |________ARCHIVE_FILE_MEMBER_n________________|
*       |               "ar_hdr"                      |
*       |.............................................|
*       |               Member Contents               |
*       |_____________________________________________|
*
*/

#define ARMAG   "!<arch>\n"
#define SARMAG  8
#define ARFMAG  "`\n"

struct ar_hdr           /* archive file member header - printable ascii */
{
        char    ar_name[16];    /* file member name - `/' terminated */
        char    ar_date[12];    /* file member date - decimal */
        char    ar_uid[6];      /* file member user id - decimal */
        char    ar_gid[6];      /* file member group id - decimal */
        char    ar_mode[8];     /* file member mode - octal */
        char    ar_size[10];    /* file member size - decimal */
        char    ar_fmag[2];     /* ARFMAG - string to end header */
};

#else /* u370 || pdp11 */

#define ARMAG   0177545
struct ar_hdr
{
        char    ar_name[14];
        long    ar_date;
        char    ar_uid;
        char    ar_gid;
        int     ar_mode;
        long    ar_size;
};

#endif
assert.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)assert.h     1.1 86/05/15";
*/
/*      @(#)assert.h    1.4     */
#ifdef NDEBUG
#define assert(EX)
#else
extern void _assert();
#define assert(EX) if (EX) ; else _assert("EX", __FILE__, __LINE__)
#endif
core.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)core.h       1.1 86/05/15";
*/
/*      @(#)core.h      1.2.1.1 */
/* machine dependent stuff for core files */

#if vax
#define TXTRNDSIZ 512L
#define stacktop(siz) (0x80000000L)
#define stackbas(siz) (0x80000000L-siz)
#endif

#if pdp11
#define TXTRNDSIZ 8192L
#define stacktop(siz) (0x10000L)
#define stackbas(siz) (0x10000L-siz)
#endif


#if u3b
#define TXTRNDSIZ 0x20000
#define stacktop(siz) 0xF00000
#define stackbas(siz) (0xF00000 + siz)
#endif

#if u3b5
#define TXTRNDSIZ 2048L
#define stacktop(siz) (0xF00000 + siz)
#define stackbas(siz) 0xF00000
#endif

#if m68k
#define TXTRNDSIZ 512L
#if M68020      /* 32-bit addresses */
#define stacktop(siz) (0xffffffffL)     /* can't represent 2^32 */
#define stackbas(siz) (-siz)            /* 2^32 - siz */
#else           /* 24-bit addresses */
#define stacktop(siz) (0x1000000L)
#define stackbas(siz) (0x1000000L-siz)
#endif
#endif
cpio.h

/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)cpio.h       1.3 87/04/14";
*/

#define M_ASCII "070707"        /* ASCII  magic number */
#define M_BINARY 070707         /* Binary magic number */
#define MAGIC   070707          /* cpio magic number -- used only by find*/
#define CHARS   76              /* ASCII header size minus filename field */
#define BUFSIZE 1024
#define CPIOBSZ 4096            /* file read/write */
#define HDRSIZE (Hdr.h_name-(char *)&Hdr) /* header size minus filename field */

        /* Cpio header format */
struct header {
        short           h_magic       ,
                        h_dev         ;
        unsigned short  h_ino         ,
                        h_mode        ,
                        h_uid         ,
                        h_gid         ;
        short           h_nlink       ,
                        h_rdev        ,
                        h_mtime[2]    ,
                        h_namesize    ,
                        h_filesize[2] ;
        char            h_name[256]   ;
} Hdr;
ctype.h
/*      Copyright (c) 1984 AT&T */
/*        All Rights Reserved   */

/*      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T     */
/*      The copyright notice above does not evidence any        */
/*      actual or intended publication of such source code.     */

/* --------------------------------------------------------------------------
   COPYRIGHT (c) 1990   TEXAS INSTRUMENTS INCORPORATED   ALL RIGHTS RESERVED
  --------------------------------------------------------------------------- */
#ident "@(#)ctype.h     1.2 90/11/28"
/*      3.0 SID #       1.2     */
#define _U      01      /* Upper case */
#define _L      02      /* Lower case */
#define _N      04      /* Numeral (digit) */
#define _S      010     /* Spacing character */
#define _P      020     /* Punctuation */
#define _C      040     /* Control character */
#define _B      0100    /* Blank */
#define _X      0200    /* heXadecimal digit */

#ifndef lint
extern char     _ctype[];

#define isalpha(c)      ((_ctype + 1)[c] & (_U | _L))
#define isupper(c)      ((_ctype + 1)[c] & _U)
#define islower(c)      ((_ctype + 1)[c] & _L)
#define isdigit(c)      ((_ctype + 1)[c] & _N)
#define isxdigit(c)     ((_ctype + 1)[c] & _X)
#define isalnum(c)      ((_ctype + 1)[c] & (_U | _L | _N))
#define isspace(c)      ((_ctype + 1)[c] & _S)
#define ispunct(c)      ((_ctype + 1)[c] & _P)
#define isprint(c)      ((_ctype + 1)[c] & (_P | _U | _L | _N | _B))
#define isgraph(c)      ((_ctype + 1)[c] & (_P | _U | _L | _N))
#define iscntrl(c)      ((_ctype + 1)[c] & _C)
#define isascii(c)      (!((c) & ~0177))
#define _toupper(c)     ((_ctype + 258)[c])
#define _tolower(c)     ((_ctype + 258)[c])
#define toascii(c)      ((c) & 0177)
#endif
curses.h
/*      Copyright (c) 1984 AT&T */
/*        All Rights Reserved   */

/*      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T     */
/*      The copyright notice above does not evidence any        */
/*      actual or intended publication of such source code.     */


/*
 * curses.h - this file is automatically made from caps and
 *      curses.ed. Don't make changes directly to curses.h!
 */
#ifndef CURSES_H

#define CURSES_H        /* define prevents multiple includes */

#include  <stdio.h>

  /*
   * This trick is used to distinguish between SYSV and V7 systems.
   * We assume that L_ctermid is only defined in stdio.h in SYSV
   * systems, but not in V7 or Berkeley UNIX.
   */
#ifdef L_ctermid
# define SYSV
#endif
   /* Some V7 systems define L_ctermid - we list those here */
#ifdef sun
# undef SYSV
#endif

#ifdef SYSV
# ifndef VINTR
#  include <termio.h>
# endif /* VINTR */
    typedef struct termio SGTTY;
#else /* !SYSV */
# ifndef _SGTTYB_
#  include <sgtty.h>
# endif /* _SGTTYB_ */
    typedef struct sgttyb SGTTY;
/*
 * Here we attempt to improve portability by providing some #defines
 * for SYSV functions on non-SYSV systems.
 */

# define memcpy(dst, src, len)  bcopy((src), (dst), (len))
# define strchr                 index
# define strrchr                rindex
#endif /* SYSV */

typedef char bool;

#define _VR3_COMPAT_CODE
/*
 * chtype is the type used to store a character together with attributes.
 * It can be set to "char" to save space, or "long" to get more attributes.
 */
#ifdef  CHTYPE
        typedef CHTYPE chtype;
#else
        typedef unsigned long chtype;
#endif /* CHTYPE */

/*
        Define for the 'old' definition of chtype is required
        when we are running in compatibility mode
*/
#ifdef _VR3_COMPAT_CODE
typedef unsigned short _ochtype;
#endif

/* TRUE and FALSE get defined so many times, */
/* let's not get in the way of other definitions. */
#if     !defined(TRUE) || ((TRUE) != 1)
#define TRUE    (1)
#endif
#if     !defined(FALSE) || ((FALSE) != 0)
#define FALSE   (0)
#endif
#if     !defined(ERR) || ((ERR) != -1)
#define ERR     (-1)
#endif
#if     !defined(OK) || ((OK) != 0)
#define OK      (0)
#endif

/* short-hand notations */
typedef struct _win_st  WINDOW;
typedef struct screen   SCREEN;

struct _win_st
{
        short           _cury, _curx;   /* current coordinates */
        short           _maxy, _maxx;   /* max coordinates */
        short           _begy, _begx;   /* (0,0) screen coordinates */
        char            _flags;
        short           _yoffset;       /* actual begy is _begy+_yoffset */
        bool            _clear, /* clearok() info */
                        _leave, /* leaveok() info */
                        _immed, /* window in immediate mode */
                        _sync;          /* auto syncup of parent */
        WINDOW          *_padwin;       /* "pad" area for current window */
#ifdef  _VR3_COMPAT_CODE
        _ochtype        **_y16; /* MUST stay at this offset in WINDOW */
#endif
        short           *_firstch;      /* first change in line */
        short           *_lastch;       /* last change in line */
        short           _tmarg, _bmarg; /* scrolling region bounds */
                                /* MUST stay at this offset in WINDOW */
        unsigned        _scroll         : 1;    /* scrollok() info */
        unsigned        _use_idl        : 1;
        unsigned        _use_keypad     : 1;
        unsigned        _notimeout      : 1;
        unsigned        _use_idc        : 1;
        chtype          _attrs; /* current window attributes */
        chtype          _bkgd;          /* background, normally blank */
        int             _delay;         /* delay period on wgetch
                                         * 0:  for nodelay
                                         * <0: for infinite delay
                                         * >0: delay time in units of millisec
                                         */
        short           _ndescs;        /* number of descendants */
        short           _parx, _pary;   /* coords relative to parent (0,0) */
        WINDOW          *_parent;       /* the parent if this is a subwin */
        chtype          **_y;                   /* lines of data */
};

/* _lastch is initially set to this, _firstch is set to win->_maxx */
#define _NOCHANGE       -1
#define _INFINITY       16000   /* no line can be longer than this */

/* values for win->_flags */
#define _ISPAD          001
#define _WINCHANGED     002
#define _WINMOVED       004
#define _WINSDEL        010
#define _CANT_BE_IMMED  020
#define _WIN_ADD_ONE    040
#define _WIN_INS_ONE    100

#define STUPID          0
#define UNKNOWN         1
#define CURS_BAD_MALLOC 2

/*
 * Various tricks to shut up lint about things that are perfectly fine.
 */
#if     defined(lint) && !defined(CURSES) /* if not internal to curses source */
 struct screen {
         int _nobody_;
 };
#endif /* lint */

/* common external variables */

extern  int     LINES, COLS, TABSIZE, COLORS, COLOR_PAIRS;

extern  short   curs_errno;

extern  WINDOW  *stdscr, *curscr;

extern  char    ttytype[];

/* Function declarations */

extern  SCREEN  *newscreen(/*termname,lines,cols,tabsiz,fout,fin*/),
                *setcurscreen(/*screenptr*/);

extern  WINDOW  *initscr(),
                *newwin(/*nlines,ncols,begy,begx*/),
                *newpad(/*nlines,ncols*/),
                *derwin(/*orig,nlines,ncols,begy,begx*/),
                *dupwin(/*orig*/),
                *getwin(/*file*/);

extern  chtype  winch();

extern  int     wgetch(); /* because it can return KEY_*, for instance. */

extern  char    *longname(),    /* long name of terminal */
                *termname(),    /* effective terminal name */
                *keyname(/*int*/), /* name of token returned by wgetch() */
                *slk_label(/*index*/),
                curs_parm_err[],
                *curs_err_strings[],
                erasechar(),
                killchar();


extern  void    vidupdate(), wsyncup(), wsyncdown(),
                delkeymap(),
                _ring(), delscreen(), curserr(),
                _setqiflush(),
                immedok(),
                wtimeout(), wbkgdset(),
                wcursyncup();

extern  int     cbreak(), nocbreak(),
                reset_prog_mode(), reset_shell_mode(), def_prog_mode(),
                _setecho(), _setnonl(),
                def_shell_mode(), raw(),
                savetty(), traceon(), _meta(),
                traceoff(), noraw(), flushinp(), _getsyx(),
                nodelay(), resetty(), ripoffline(), setsyx(), slk_refresh(),
                slk_restore(), notimeout(), clearok(), leaveok(),
                scrollok(), wstandend(), wstandout();

extern  int     crmode(), nocrmode(), ungetch();

#define getsyx(y,x)             _getsyx(&(y),&(x))

/*
 * Functions to get at the window structure.
 */

#define getyx(win,y,x)          ((y) = getcury(win), (x) = getcurx(win))
#define getbegyx(win,y,x)       ((y) = getbegy(win), (x) = getbegx(win))
#define getmaxyx(win,y,x)       ((y) = getmaxy(win), (x) = getmaxx(win))
#define getparyx(win,y,x)       ((y) = getpary(win), (x) = getparx(win))

#if     defined(PERFORMANCE) && !defined(lint)
#define getcury(win)            ((win)->_cury)
#define getcurx(win)            ((win)->_curx)
#define getbegy(win)            ((win)->_begy)
#define getbegx(win)            ((win)->_begx)
#define getmaxy(win)            ((win)->_maxy)
#define getmaxx(win)            ((win)->_maxx)
#define getpary(win)            ((win)->_pary)
#define getparx(win)            ((win)->_parx)
#define getbkgd(win)            ((win)->_bkgd)
#define getattrs(win)           ((win)->_attrs)
#endif  /* defined(PERFORMANCE) && !defined(lint) */

#ifdef  _VR3_COMPAT_CODE

#define newterm         newterm32
extern  SCREEN  *newterm(/*termname,fout,fin*/),
                *set_term(/*screenptr*/);

extern  WINDOW  *initscr32(),
                *subwin(/*orig,nlines,ncols,sbegy,sbegx*/),
                *subpad(/*orig,nlines,ncols,begy,begx*/);

extern  _ochtype        *acs_map;

extern  chtype  *acs32map;

/* definitions for Vr3 source compatibility */

#define initscr         initscr32
#define waddch          w32addch
#define wechochar       w32echochar
#define pechochar       p32echochar
#define winsch          w32insch
#define vidputs         vid32puts
#define vidattr         vid32attr
#define wattroff        w32attroff
#define wattron         w32attron
#define wattrset        w32attrset
#define acs_map         acs32map
#define box             box32

#else   /* _VR3_COMPAT_CODE */

extern  chtype  *acs_map;

#endif  /* _VR3_COMPAT_CODE */

extern  int     wattroff(), wattron(), wattrset();

#if     defined(NOMACROS) || defined(lint)

extern  SCREEN  *newterm(/*termname,fout,fin*/),
                *set_term(/*screenptr*/);

extern  WINDOW  *subpad(),
                *subwin();

extern  char    *unctrl();

extern  chtype  inch(),
                mvinch(),
                mvwinch();

extern  int     intrflush(), meta(), noecho(), echo(), nl(), nonl(), beep(),
                flash(), attroff(), attron(), attrset(), standend(),
                standout();

extern  void    bkgdset(), timeout();

#else   /* NOMACROS || lint */

/*
 * The defines from here down to the #endif for NOMACROS
 * define macros, which may be more efficient than their
 * function versions. The functions may be accessed by defining
 * NOMACROS in C code. This is useful for debugging purposes.
 */

#include  <unctrl.h>

/* pseudo functions for stdscr */
#define addch(ch)       waddch(stdscr, ch)
#define addnstr(s,n)    waddnstr(stdscr,s,n)
#define addstr(str)     waddstr(stdscr, str)
#define attroff(at)     wattroff(stdscr,at)
#define attron(at)      wattron(stdscr,at)
#define attrset(at)     wattrset(stdscr,at)
#define bkgd(c)         wbkgd(stdscr,c)
#define border(ls, rs, ts, bs, tl, tr, bl, br)  wborder(stdscr, ls, rs, ts, bs, tl, tr, bl, br)
#define clear()         wclear(stdscr)
#define clrtobot()      wclrtobot(stdscr)
#define clrtoeol()      wclrtoeol(stdscr)
#define delch()         wdelch(stdscr)
#define deleteln()      wdeleteln(stdscr)
#define echochar(ch)    wechochar(stdscr, ch)
#define erase()         werase(stdscr)
#define getch()         wgetch(stdscr)
#define getstr(str)     wgetstr(stdscr, str)
#define inch()          winch(stdscr)
#define insch(c)        winsch(stdscr,c)
#define insdelln(id)    winsdelln(stdscr,id)
#define insertln()      winsertln(stdscr)
#define insnstr(s,n)    winsnstr(stdscr,s,n)
#define insstr(s)       winsstr(stdscr,s)
#define move(y, x)      wmove(stdscr, y, x)
#define refresh()       wrefresh(stdscr)
#define scrl(n)         wscrl(stdscr,n)
#define setscrreg(t,b)  wsetscrreg(stdscr, t, b)
#define standend()      wstandend(stdscr)
#define standout()      wstandout(stdscr)
#define timeout(tm)     wtimeout(stdscr,tm)
#define hline(c,num)    whline(stdscr,c,num)
#define vline(c,num)    wvline(stdscr,c,num)
#define addchstr(str)   waddchstr(stdscr,str)
#define addchnstr(str,n)        waddchnstr(stdscr,str,n)
#define instr(str)      winstr(stdscr,(str))
#define innstr(str,n)   winnstr(stdscr,(str),(n))
#define inchstr(str)    winchstr(stdscr,str)
#define inchnstr(str,n) winchnstr(stdscr,str,n)
#define bkgdset(c)      wbkgdset(stdscr,c)

/* functions to define environment flags of a window */
#ifdef  PERFORMANCE
#define wbkgdset(win,c)         (((win)->_attrs = (((win)->_attrs & ~((win)->_bkgd & A_ATTRIBUTES)) | (c & A_ATTRIBUTES))), ((win)->_bkgd = (c)))
#define syncok(win,bf)          ((win)->_parent?(win)->_sync=(bf):ERR)
#define notimeout(win,bf)       ((win)->_notimeout = ((bf) ? TRUE : FALSE))
#define clearok(win,bf)         ((win)->_clear = (bf))
#define leaveok(win,bf)         ((win)->_leave = (bf))
#define scrollok(win,bf)        ((win)->_scroll = ((bf) ? TRUE : FALSE))
#define idcok(win,bf)           ((win)->_use_idc = ((bf) ? TRUE : FALSE))
#define nodelay(win,bf)         ((win)->_delay = (bf) ? 0 : -1)
#define is_wintouched(win)      ((win)->_flags & _WINCHANGED)
#define is_linetouched(win,line)        ((((line) >= (win)->_maxy) || \
                                     ((line) < 0)) ? ERR : \
                                    (((win)->_firstch[(line)] == _INFINITY) ? \
                                                                  FALSE : TRUE))
#endif  /* PERFORMANCE */

/* functions for move and update */
#define mvaddch(y,x,ch)         mvwaddch(stdscr,y,x,ch)
#define mvaddnstr(y,x,s,n)      mvwaddnstr(stdscr,y,x,s,n)
#define mvaddstr(y,x,str)       mvwaddstr(stdscr,y,x,str)
#define mvdelch(y,x)            mvwdelch(stdscr,y,x)
#define mvgetch(y,x)            mvwgetch(stdscr,y,x)
#define mvgetstr(y,x,str)       mvwgetstr(stdscr,y,x,str)
#define mvinch(y,x)             mvwinch(stdscr,y,x)
#define mvinsch(y,x,c)          mvwinsch(stdscr,y,x,c)
#define mvinsnstr(y,x,s,n)      mvwinsnstr(stdscr,y,x,s,n)
#define mvinsstr(y,x,s)         mvwinsstr(stdscr,y,x,s)
#define mvaddchstr(y,x,str)     mvwaddchstr(stdscr,y,x,str)
#define mvaddchnstr(y,x,str,n)  mvwaddchnstr(stdscr,y,x,str,n)
#define mvinstr(y,x,str)        mvwinstr(stdscr,y,x,(str))
#define mvinnstr(y,x,str,n)     mvwinnstr(stdscr,y,x,(str),(n))
#define mvinchstr(y,x,str)      mvwinchstr(stdscr,y,x,str)
#define mvinchnstr(y,x,str,n)   mvwinchnstr(stdscr,y,x,str,n)
#define mvhline(y,x,c,num)      mvwhline(stdscr,y,x,c,num)
#define mvvline(y,x,c,num)      mvwvline(stdscr,y,x,c,num)

#define mvwaddch(win,y,x,ch)    (wmove(win,y,x)==ERR?ERR:waddch(win,ch))
#define mvwaddnstr(win,y,x,s,n) (wmove(win,y,x)==ERR?ERR:waddnstr(win,s,n))
#define mvwaddstr(win,y,x,str)  (wmove(win,y,x)==ERR?ERR:waddstr(win,str))
#define mvwdelch(win,y,x)       (wmove(win,y,x)==ERR?ERR:wdelch(win))
#define mvwgetch(win,y,x)       (wmove(win,y,x)==ERR?ERR:wgetch(win))
#define mvwgetstr(win,y,x,str)  (wmove(win,y,x)==ERR?ERR:wgetstr(win,str))
#define mvwinch(win,y,x)        (wmove(win,y,x)==ERR?(chtype) ERR:winch(win))
#define mvwinsch(win,y,x,c)     (wmove(win,y,x)==ERR?ERR:winsch(win,c))
#define mvwinsnstr(win,y,x,s,n) (wmove(win,y,x)==ERR?ERR:winsnstr(win,s,n))
#define mvwinsstr(win,y,x,s)    (wmove(win,y,x)==ERR?ERR:winsstr(win,s))
#define mvwhline(win,y,x,c,num) (wmove(win,y,x)==ERR?ERR:whline(win,c,num))
#define mvwvline(win,y,x,c,num) (wmove(win,y,x)==ERR?ERR:wvline(win,c,num))
#define mvwaddchstr(win,y,x,str)        (wmove(win,y,x)==ERR?ERR:waddchstr(win,str))
#define mvwaddchnstr(win,y,x,str,n)     (wmove(win,y,x)==ERR?ERR:waddchnstr(win,str,n))
#define mvwinstr(win,y,x,str)   (wmove(win,y,x)==ERR?ERR:winstr(win,str))
#define mvwinnstr(win,y,x,str,n)        (wmove(win,y,x)==ERR?ERR:winnstr(win,str,n))
#define mvwinchstr(win,y,x,str) (wmove(win,y,x)==ERR?ERR:winchstr(win,str))
#define mvwinchnstr(win,y,x,str,n)      (wmove(win,y,x)==ERR?ERR:winchnstr(win,str,n))

#ifdef CURSES_MACROS
#define overlay(src,dst)        _overlap((src),(dst),TRUE)
#define overwrite(src,dst)      _overlap((src),(dst),FALSE)
#define wdeleteln(win)          winsdelln((win),-1)
#define winsertln(win)          winsdelln((win),1)
#define wstandend(win)          wattrset((win),A_NORMAL)
#define wstandout(win)          wattron((win),A_STANDOUT)
#define beep()                  _ring(TRUE)
#define flash()                 _ring(FALSE)
#define scroll(win)             wscrl((win),1)
#define slk_init(f)             slk_start(((f == 0) ? 3 : 2),NULL)
#define scr_init(file)          _scr_all(file,0)
#define scr_restore(file)       _scr_all(file,1)
#define subpad(win,nl,nc,by,bx) derwin((win),(nl),(nc),(by),(bx))
#define box(win,v,h)            wborder((win),(v),(v),(h),(h),0,0,0,0)
#define newterm(type,fout,fin)  newscreen((type),0,0,0,(fout),(fin))
#define touchline(win,y,n)      wtouchln((win),(y),(n),TRUE)
#endif /* CURSES_MACROS */

#define garbagedlines           wredrawln
#define garbagedwin             redrawwin
#ifdef  PERFORMANCE
#define subwin(win,nl,nc,by,bx) derwin((win),(nl),(nc),(by-win->_begy),(bx-win->_begx))
#define touchwin(win)           wtouchln((win),0,(win)->_maxy,TRUE)
#define redrawwin(win)          wredrawln((win),0,(win)->_maxy)
#define winchstr(win,str)       winchnstr((win),str,((win)->_maxx - (win)->_curx))
#define winstr(win,str)         winnstr((win),str,((win)->_maxx - (win)->_curx))
#define untouchwin(win)         wtouchln((win),0,((win)->_maxy),FALSE)
#define winch(win)              ((win)->_y[(win)->_cury][(win)->_curx])
#endif  /* PERFORMANCE */

#ifdef CURSES_MACROS
#define waddstr(win,str)        waddnstr((win),(str),-1)
#define werase(win)             (wmove((win),0,0), wclrtobot(win))
#define wclear(win)             (clearok((win),TRUE), werase(win))
#define intrflush(win,flag)     _setqiflush(flag)
#define meta(win,flag)          _meta(flag)
#endif /* CURSES_MACROS */

#define crmode                  cbreak
#define nocrmode                nocbreak
#define saveterm                def_prog_mode
#define fixterm                 reset_prog_mode
#define resetterm               reset_shell_mode

#ifdef CURSES_MACROS
#define setterm(name)           setupterm((name),1,(char*)NULL)
#define gettmode()              (OK)
#define halfdelay(tens)         ttimeout((tens)*100)
#endif /* CURSES_MACROS */

#define waddchstr(win,str)      waddchnstr((win),(str),-1)
#define winsstr(win,str)        winsnstr((win),(str),-1)

/* iocontrol functions */
#define qiflush()               _setqiflush(TRUE)
#define noqiflush()             _setqiflush(FALSE)

#ifdef CURSES_MACROS
#define echo()                  _setecho(TRUE)
#define noecho()                _setecho(FALSE)
#define nl()                    _setnonl(FALSE)
#define nonl()                  _setnonl(TRUE)
#endif /* CURSES_MACROS */

/* functions for setting time-out length on inputs */
#ifdef  PERFORMANCE
#define wtimeout(win,tm)        ((win)->_delay = (tm))

/* functions for accessing selected TERMINAL fields     */
#define can_change_color()      can_change
#define has_colors()            ((max_pairs == -1) ? FALSE : TRUE)
#endif  /* PERFORMANCE */

#define set_term                setcurscreen
#define scr_set(file)           _scr_all(file,2)

#endif  /* NOMACROS || lint */

/*
 * Standard alternate character set.  The current ACS world is evolving,
 * so we support only a widely available subset: the line drawing characters
 * from the VT100, plus a few from the Teletype 5410v1.  Eventually there
 * may be support of more sophisticated ACS line drawing, such as that
 * in the Teletype 5410, the HP line drawing set, and the like.  There may
 * be support for some non line oriented characters as well.
 *
 * Line drawing ACS names are of the form ACS_trbl, where t is the top, r
 * is the right, b is the bottom, and l is the left.  t, r, b, and l might
 * be B (blank), S (single), D (double), or T (thick).  The subset defined
 * here only uses B and S.
 */

#define ACS_BSSB        (acs_map['l'])
#define ACS_SSBB        (acs_map['m'])
#define ACS_BBSS        (acs_map['k'])
#define ACS_SBBS        (acs_map['j'])
#define ACS_SBSS        (acs_map['u'])
#define ACS_SSSB        (acs_map['t'])
#define ACS_SSBS        (acs_map['v'])
#define ACS_BSSS        (acs_map['w'])
#define ACS_BSBS        (acs_map['q'])
#define ACS_SBSB        (acs_map['x'])
#define ACS_SSSS        (acs_map['n'])

/*
 * Human readable names for the most commonly used characters.
 * "Upper", "right", etc. are chosen to be consistent with the vt100 manual.
 */

#define ACS_ULCORNER    ACS_BSSB
#define ACS_LLCORNER    ACS_SSBB
#define ACS_URCORNER    ACS_BBSS
#define ACS_LRCORNER    ACS_SBBS
#define ACS_RTEE        ACS_SBSS
#define ACS_LTEE        ACS_SSSB
#define ACS_BTEE        ACS_SSBS
#define ACS_TTEE        ACS_BSSS
#define ACS_HLINE       ACS_BSBS
#define ACS_VLINE       ACS_SBSB
#define ACS_PLUS        ACS_SSSS
#define ACS_S1          (acs_map['o'])  /* scan line 1 */
#define ACS_S9          (acs_map['s'])  /* scan line 9 */
#define ACS_DIAMOND     (acs_map['`'])  /* diamond */
#define ACS_CKBOARD     (acs_map['a'])  /* checker board (stipple) */
#define ACS_DEGREE      (acs_map['f'])  /* degree symbol */
#define ACS_PLMINUS     (acs_map['g'])  /* plus/minus */
#define ACS_BULLET      (acs_map['~'])  /* bullet */
        /* Teletype 5410v1 symbols */
#define ACS_LARROW      (acs_map[','])  /* arrow pointing left */
#define ACS_RARROW      (acs_map['+'])  /* arrow pointing right */
#define ACS_DARROW      (acs_map['.'])  /* arrow pointing down */
#define ACS_UARROW      (acs_map['-'])  /* arrow pointing up */
#define ACS_BOARD       (acs_map['h'])  /* board of squares */
#define ACS_LANTERN     (acs_map['i'])  /* lantern symbol */
#define ACS_BLOCK       (acs_map['0'])  /* solid square block */

/* Funny "characters" enabled for various special function keys for input */
/* This list is created from caps and curses.ed. Do not edit it! */
#define KEY_MIN         0401            /* Minimum curses key */
#define KEY_BREAK       0401            /* break key (unreliable) */
#define KEY_DOWN        0402            /* Sent by terminal down arrow key */
#define KEY_UP          0403            /* Sent by terminal up arrow key */
#define KEY_LEFT        0404            /* Sent by terminal left arrow key */
#define KEY_RIGHT       0405            /* Sent by terminal right arrow key */
#define KEY_HOME        0406            /* Sent by home key. */
#define KEY_BACKSPACE   0407            /* Sent by backspace key */
#define KEY_F0          0410            /* function key f0. */
#define KEY_F(n)        (KEY_F0+(n))    /* Space for 64 function keys is reserved. */
#define KEY_DL          0510            /* Sent by delete line key. */
#define KEY_IL          0511            /* Sent by insert line. */
#define KEY_DC          0512            /* Sent by delete character key. */
#define KEY_IC          0513            /* Sent by ins char/enter ins mode key. */
#define KEY_EIC         0514            /* Sent by rmir or smir in insert mode. */
#define KEY_CLEAR       0515            /* Sent by clear screen or erase key. */
#define KEY_EOS         0516            /* Sent by clear-to-end-of-screen key. */
#define KEY_EOL         0517            /* Sent by clear-to-end-of-line key. */
#define KEY_SF          0520            /* Sent by scroll-forward/down key */
#define KEY_SR          0521            /* Sent by scroll-backward/up key */
#define KEY_NPAGE       0522            /* Sent by next-page key */
#define KEY_PPAGE       0523            /* Sent by previous-page key */
#define KEY_STAB        0524            /* Sent by set-tab key */
#define KEY_CTAB        0525            /* Sent by clear-tab key */
#define KEY_CATAB       0526            /* Sent by clear-all-tabs key. */
#define KEY_ENTER       0527            /* Enter/send (unreliable) */
#define KEY_SRESET      0530            /* soft (partial) reset (unreliable) */
#define KEY_RESET       0531            /* reset or hard reset (unreliable) */
#define KEY_PRINT       0532            /* print or copy */
#define KEY_LL          0533            /* Sent by home-down key */
                                        /* The keypad is arranged like this: */
                                        /*    a1    up    a3   */
                                        /*   left   b2  right  */
                                        /*    c1   down   c3   */
#define KEY_A1          0534            /* Upper left of keypad */
#define KEY_A3          0535            /* Upper right of keypad */
#define KEY_B2          0536            /* Center of keypad */
#define KEY_C1          0537            /* Lower left of keypad */
#define KEY_C3          0540            /* Lower right of keypad */
#define KEY_BTAB        0541            /* Back tab key */
#define KEY_BEG         0542            /* beg(inning) key */
#define KEY_CANCEL      0543            /* cancel key */
#define KEY_CLOSE       0544            /* close key */
#define KEY_COMMAND     0545            /* cmd (command) key */
#define KEY_COPY        0546            /* copy key */
#define KEY_CREATE      0547            /* create key */
#define KEY_END         0550            /* end key */
#define KEY_EXIT        0551            /* exit key */
#define KEY_FIND        0552            /* find key */
#define KEY_HELP        0553            /* help key */
#define KEY_MARK        0554            /* mark key */
#define KEY_MESSAGE     0555            /* message key */
#define KEY_MOVE        0556            /* move key */
#define KEY_NEXT        0557            /* next object key */
#define KEY_OPEN        0560            /* open key */
#define KEY_OPTIONS     0561            /* options key */
#define KEY_PREVIOUS    0562            /* previous object key */
#define KEY_REDO        0563            /* redo key */
#define KEY_REFERENCE   0564            /* ref(erence) key */
#define KEY_REFRESH     0565            /* refresh key */
#define KEY_REPLACE     0566            /* replace key */
#define KEY_RESTART     0567            /* restart key */
#define KEY_RESUME      0570            /* resume key */
#define KEY_SAVE        0571            /* save key */
#define KEY_SBEG        0572            /* shifted beginning key */
#define KEY_SCANCEL     0573            /* shifted cancel key */
#define KEY_SCOMMAND    0574            /* shifted command key */
#define KEY_SCOPY       0575            /* shifted copy key */
#define KEY_SCREATE     0576            /* shifted create key */
#define KEY_SDC         0577            /* shifted delete char key */
#define KEY_SDL         0600            /* shifted delete line key */
#define KEY_SELECT      0601            /* select key */
#define KEY_SEND        0602            /* shifted end key */
#define KEY_SEOL        0603            /* shifted clear line key */
#define KEY_SEXIT       0604            /* shifted exit key */
#define KEY_SFIND       0605            /* shifted find key */
#define KEY_SHELP       0606            /* shifted help key */
#define KEY_SHOME       0607            /* shifted home key */
#define KEY_SIC         0610            /* shifted input key */
#define KEY_SLEFT       0611            /* shifted left arrow key */
#define KEY_SMESSAGE    0612            /* shifted message key */
#define KEY_SMOVE       0613            /* shifted move key */
#define KEY_SNEXT       0614            /* shifted next key */
#define KEY_SOPTIONS    0615            /* shifted options key */
#define KEY_SPREVIOUS   0616            /* shifted prev key */
#define KEY_SPRINT      0617            /* shifted print key */
#define KEY_SREDO       0620            /* shifted redo key */
#define KEY_SREPLACE    0621            /* shifted replace key */
#define KEY_SRIGHT      0622            /* shifted right arrow */
#define KEY_SRSUME      0623            /* shifted resume key */
#define KEY_SSAVE       0624            /* shifted save key */
#define KEY_SSUSPEND    0625            /* shifted suspend key */
#define KEY_SUNDO       0626            /* shifted undo key */
#define KEY_SUSPEND     0627            /* suspend key */
#define KEY_UNDO        0630            /* undo key */
#define KEY_MAX         0777            /* Maximum curses key */

/*
        The definition for 'reg' is not standard, and is provided for
        compatibility reasons. User's are discouraged from using this.
*/
#define reg     register

/* Various video attributes */
#define A_STANDOUT      000000200000L
#define _STANDOUT       A_STANDOUT    /* for compatability with old curses */
#define A_UNDERLINE     000000400000L
#define A_REVERSE       000001000000L
#define A_BLINK         000002000000L
#define A_DIM           000004000000L
#define A_BOLD          000010000000L
#define A_ALTCHARSET    000100000000L

/* The next two are subject to change so don't depend on them */
#define A_INVIS         000020000000L
#define A_PROTECT       000040000000L

#define A_NORMAL        000000000000L
#define A_ATTRIBUTES    037777600000L   /* 0xFFFF0000 */
#define A_CHARTEXT      000000177777L   /* 0x0000FFFF */
#define A_COLOR         017600000000L

#define COLOR_PAIR(n)   ((n) << 25)
#define PAIR_NUMBER(n)  (((n) & A_COLOR) >> 25)

/* definition of 8 basic color  */
#define COLOR_BLACK     0
#define COLOR_BLUE      1
#define COLOR_GREEN     2
#define COLOR_CYAN      3
#define COLOR_RED       4
#define COLOR_MAGENTA   5
#define COLOR_YELLOW    6
#define COLOR_WHITE     7
#endif /* CURSES_H */
decimal.h
/*
 * The DECIMALTYPE is a machine-independent method for the representation
 * of numbers of up to thirty-two significant digits, with or without a
 * decimal point, and exponents in the range -64 to +63. DECIMALTYPE
 * numbers consist of an exponent and a mantissa (or fractional part) in
 * base 100.  In normalized form, the first digit of the mantissa must be
 * greater than zero.
 *
 * When used within a program, DECIMALTYPE numbers are stored in a C structure
 * of the type shown below.  This file should be included in all C source
 * files that use any of the decimal routines.
 */

#define DECSIZE 16

struct decimal
{
        short dec_exp;                    /* -64 to +63 */
        short dec_pos;                    /* 1: pos, 0: neg */
        short dec_ndgts;                  /* # of dec_dgts in use (0 offset) */
        unsigned char dec_dgts[DECSIZE];
};

typedef struct decimal dec_t;

/*
 * Packed format (format in records in file)
 *      First byte =
 *              top 1 bit = sign  (0=neg, 1=pos)
 *              low 7 bits = exponent in excess 64 format
 *      rest of bytes = base 100 digits in 100 complement format.
 *
 *      zero is represented as 80000...  (hex)
 */
dial.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = "@(#)dial.h      1.3 91/10/18";
*/
#ifndef IUCLC
#include <sys/termio.h>
#endif

#define TRUE    1
#define FALSE   0

                /* error mnemonics */

#define INTRPT  (-1)    /* unexpected failure */
#define D_HUNG  (-2)    /* dial failed *
#define NO_ANS  (-3)    /* caller script failed */
#define A_PROB  (-5)    /* device failed */
#define L_PROB  (-6)    /* can't access device */
#define NO_Ldv  (-7)    /* can't open Devices file */
#define DV_NT_A (-8)    /* device locked */
#define NO_BD_A (-10)   /* no devices available */
#define BAD_SYS (-13)   /* system not in Systems file */

typedef struct {
        struct termio *attr;    /* ptr to termio attribute struct */
        int     baud;           /* unused */
        int     speed;          /* line speed */
        char    *line;          /* device name for out-going line */
        char    *telno;         /* ptr to tel-no digits string or remote
                                        location name */
        int     modem;          /* unused */
        char    *device;        /* unused */
        int     dev_len;        /* unused */
} CALL;

extern int dial();
extern void undial();
dialio.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)dialio.h     1.9 89/08/24;
*/

#include <sys/dialio.h>
dirent.h
/*
    COPYRIGHT (c) 1988 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = "@(#)dirent.h    1.1 88/03/01";
*/

#define MAXNAMLEN       512             /* maximum filename length */
#define DIRBUF          1048            /* buffer size for fs-indep. dirs */


typedef struct
        {
        int     dd_fd;                  /* file descriptor */
        int     dd_loc;                 /* offset in block */
        int     dd_size;                /* amount of valid data */
        char    *dd_buf;                /* directory block */
        }       DIR;                    /* stream data from opendir() */

extern DIR              *opendir();
extern struct dirent    *readdir();
extern long             telldir();
extern void             seekdir();
extern int              closedir();

#define rewinddir( dirp )       seekdir( dirp, 0L )
#include <sys/dirent.h>
dumprestor.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)dumprestor.h 1.1 86/05/15";
*/
/*      @(#)dumprestor.h        1.1     */
/*      3.0 SID #       1.1     */
#define NTREC           20
#define MLEN            16
#define MSIZ            4096

#define TS_TAPE         1
#define TS_INODE        2
#define TS_BITS         3
#define TS_ADDR         4
#define TS_END          5
#define TS_CLRI         6
#define MAGIC           (int)60011
#define CHECKSUM        (int)84446
struct  spcl
{
        int     c_type;
        time_t  c_date;
        time_t  c_ddate;
        int     c_volume;
        daddr_t c_tapea;
        ino_t   c_inumber;
        int     c_magic;
        int     c_checksum;
        struct  dinode  c_dinode;
        int     c_count;
        char    c_addr[BSIZE];
} spcl;

struct  idates
{
        char    id_name[16];
        char    id_incno;
        time_t  id_ddate;
};
errno.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)errno.h      1.1 86/05/15";
*/
/*      @(#)errno.h     1.2     */
/*      3.0 SID #       1.3     */
/*
 * Error codes
 */

#include <sys/errno.h>
extern int errno;
execargs.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)execargs.h   1.1 86/05/15";
*/
/*      @(#)execargs.h  1.2     */
#if vax
char **execargs = (char**)(0x7ffffffc);
#endif

#if pdp11
char **execargs = (char**)(-2);
#endif

#if u3b || u3b5
/* empty till we can figure out what to do for the shell */
#endif

#if m68k
#if M68020      /* 32-bit addresses */
char **execargs = (char**)(0xfffffffc);
#else           /* 24-bit addresses */
char **execargs = (char**)(0xfffffc);
#endif
#endif
fatal.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)fatal.h      1.2 86/07/01";
*/
/*      @(#)fatal.h     1.2     */

#include <setjmp.h>

extern  int     Fflags;
extern  char    *Ffile;
extern  int     Fvalue;
extern  int     (*Ffunc)();
extern  jmp_buf Fjmp;           /* s1500:  change from int [10]  to jmp_buf  */

# define FTLMSG         0100000
# define FTLCLN          040000
# define FTLFUNC         020000
# define FTLACT             077
# define FTLJMP              02
# define FTLEXIT             01
# define FTLRET               0

# define FSAVE(val)     SAVE(Fflags,old_Fflags); Fflags = val;
# define FRSTR()        RSTR(Fflags,old_Fflags);
fcntl.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)fcntl.h      1.3 89/08/17";
*/
/*    @(#)fcntl.h       1.3    */
/* Flag values accessible to open(2) and fcntl(2) */
/*  (The first three can only be set by open) */

#include "sys/fcntl.h"
filehdr.h
/*      Copyright (c) 1984 AT&T */
/*        All Rights Reserved   */

/*      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T     */
/*      The copyright notice above does not evidence any        */
/*      actual or intended publication of such source code.     */

#ident  "@(#)filehdr.h  1.3 92/02/28"

struct filehdr {
        unsigned short  f_magic;        /* magic number */
        unsigned short  f_nscns;        /* number of sections */
        long            f_timdat;       /* time & date stamp */
        long            f_symptr;       /* file pointer to symtab */
        long            f_nsyms;        /* number of symtab entries */
        unsigned short  f_opthdr;       /* sizeof(optional hdr) */
        unsigned short  f_flags;        /* flags */
        };

/*
 *   Bits for f_flags:
 *
 *      F_RELFLG        relocation info stripped from file
 *      F_EXEC          file is executable  (i.e. no unresolved
 *                              externel references)
 *      F_LNNO          line nunbers stripped from file
 *      F_LSYMS         local symbols stripped from file
 *      F_MINMAL        this is a minimal object file (".m") output of fextract
 *      F_UPDATE        this is a fully bound update file, output of ogen
 *      F_SWABD         this file has had its bytes swabbed (in names)
 *      F_AR16WR        this file has the byte ordering of an AR16WR (e.g. 11/70) machine
 *                              (it was created there, or was produced by conv)
 *      F_AR32WR        this file has the byte ordering of an AR32WR machine(e.g. vax)
 *      F_AR32W         this file has the byte ordering of an AR32W machine (e.g. 3b,maxi)
 *      F_PATCH         file contains "patch" list in optional header
 *      F_NODF          (minimal file only) no decision functions for
 *                              replaced functions
 */

#define  F_RELFLG       0000001
#define  F_EXEC         0000002
#define  F_LNNO         0000004
#define  F_LSYMS        0000010
#define  F_MINMAL       0000020
#define  F_UPDATE       0000040
#define  F_SWABD        0000100
#define  F_AR16WR       0000200
#define  F_AR32WR       0000400
#define  F_AR32W        0001000
#define  F_PATCH        0002000
#define  F_NODF         0002000

/*
 *      BELLMAC-32      Identification field
 *      F_BM32B         file contains BM32B code (as opposed to strictly BM32A)
 *      F_BM32MAU       file requires MAU (math arith unit) to execute
 */

#define F_BM32ID        0160000
#define F_BM32MAU       0040000
#define F_BM32B         0020000

/*      F_BM32RST       file has RESTORE work-around    */

#define F_BM32RST       0010000

/*
 *      Flags for the INTEL chips.  If the magic number of the object file
 *      is IAPX16 or IAPX16TV or IAPX20 or IAPX20TV then if F_80186
 *      is set, there are some 80186 instructions in the code, and hence
 *      and 80186 or 80286 chip must be used to run the code.
 *      If F_80286 is set, then the code has to be run on an 80286 chip.
 *      And if neither are set, then the code can run on an 8086, 80186, or
 *      80286 chip.
 *
 */

#define F_80186         010000
#define F_80286         020000

/*      Flags for Motorola chips.
*/
#define F_CINHDAT       010000  /* DATA Segment must be cache-inhibited */

/*
 *   Magic Numbers
 */

        /* iAPX - the stack frame and return registers differ from
         *        Basic-16 and x86 C compilers, hence new magic numbers
         *        are required.  These are cross compilers.
         */

        /* Intel */
#define  IAPX16         0504
#define  IAPX16TV       0505
#define  IAPX20         0506
#define  IAPX20TV       0507
/* 0514, 0516 and 0517 reserved for Intel */

        /* Basic-16 */

#define  B16MAGIC       0502
#define  BTVMAGIC       0503


        /* x86 */

#define  X86MAGIC       0510
#define  XTVMAGIC       0511

        /* Intel 286 */
#define I286SMAGIC      0512
#define I286LMAGIC      0522    /* used by mc68000 (UNIX PC) and iAPX 286 */

        /* n3b */
/*
 *   NOTE:   For New 3B, the old values of magic numbers
 *              will be in the optional header in the structure
 *              "aouthdr" (identical to old 3B aouthdr).
 */
#define  N3BMAGIC       0550    /* 3B20 executable, no TV */
#define  NTVMAGIC       0551    /* 3B20 executable with TV */

        /*  MAC-32, 3B15, 3B5  */

#define  WE32MAGIC      0560    /* WE 32000, no TV */
#define  FBOMAGIC       0560    /* WE 32000, no TV */
#define  RBOMAGIC       0562    /* reserved for WE 32000 */
#define  MTVMAGIC       0561    /* WE 32000 with TV */


        /* VAX 11/780 and VAX 11/750 */

                        /* writeable text segments */
#define VAXWRMAGIC      0570
                        /* readonly sharable text segments */
#define VAXROMAGIC      0575

        /* pdp11 */
/*                      0401    UNIX-rt ldp */
/*                      0405    pdp11 overlay */
/*                      0407    pdp11/pre System V vax executable */
/*                      0410    pdp11/pre System V vax pure executable */
/*                      0411    pdp11 seperate I&D */
/*                      0437    pdp11 kernel overlay */


        /* Motorola 68000/68008/68010/68020 */
#define MC68MAGIC       0520
#define MC68KWRMAGIC    0520    /* writeable text segments */
#define MC68TVMAGIC     0521
#define MC68KROMAGIC    0521    /* readonly shareable text segments */
#define MC68KPGMAGIC    0522    /* demand paged text segments */
#define M68MAGIC        0210
#define M68TVMAGIC      0211


        /* IBM 370 */
#define U370WRMAGIC     0530    /* writeble text segments       */
#define U370ROMAGIC     0535    /* readonly sharable text segments      */
/* 0532 and 0533 reserved for u370 */

        /* Amdahl 470/580 */
#define AMDWRMAGIC      0531    /* writable text segments */
#define AMDROMAGIC      0534    /* readonly sharable text segments */

        /* NSC */
/* 0524 and 0525 reserved for NSC */

        /* Zilog */
/* 0544 and 0545 reserved for Zilog */

#define FILHDR  struct filehdr
#define FILHSZ  sizeof(FILHDR)

#define ISCOFF(x) \
                (((x)==B16MAGIC) || ((x)==BTVMAGIC) || ((x)==X86MAGIC) \
                || ((x)==XTVMAGIC) || ((x)==N3BMAGIC) || ((x)==NTVMAGIC) \
                || ((x)==FBOMAGIC) || ((x)==VAXROMAGIC) || ((x)==VAXWRMAGIC) \
                || ((x)==RBOMAGIC) || ((x)==MC68TVMAGIC) \
                || ((x)==MC68MAGIC) || ((x)==M68MAGIC) || ((x)==M68TVMAGIC) \
                || ((x)==IAPX16) || ((x)==IAPX16TV) \
                || ((x)==IAPX20) || ((x)==IAPX20TV) \
                || ((x)==U370WRMAGIC) || ((x)==U370ROMAGIC) || ((x)==MTVMAGIC) \
                || ((x)==I286SMAGIC) || ((x)==I286LMAGIC) \
                || ((x)==MC68KWRMAGIC) || ((x)==MC68KROMAGIC) \
                || ((x)==MC68KPGMAGIC))
ftw.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)ftw.h        1.1 86/05/15";
*/
/*      @(#)ftw.h       1.1     */
/*
 *      Codes for the third argument to the user-supplied function
 *      which is passed as the second argument to ftw
 */

#define FTW_F   0       /* file */
#define FTW_D   1       /* directory */
#define FTW_DNR 2       /* directory without read permission */
#define FTW_NS  3       /* unknown type, stat failed */
grp.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)grp.h        1.1 86/05/15";
*/
/*      @(#)grp.h       1.1     */
/*      3.0 SID #       1.1     */
struct  group { /* see getgrent(3) */
        char    *gr_name;
        char    *gr_passwd;
        int     gr_gid;
        char    **gr_mem;
};
isam.h
/*
 *  COPYRIGHT (c) 1986, 1987, 1988, 1989, 1990, 1991, 1992 TEXAS INSTRUMENTS,
 *  INCORPORATED.  ALL RIGHTS RESERVED.
 *
 *  COPYRIGHT (c) 1992, 1993 HEWLETT-PACKARD COMPANY.  ALL RIGHTS RESERVED.
 *
 *  @(#)isam.h (T-ISAM) version 2.8.8  (18 February 1993)
 */
#ifndef ISINCLUDE
#define ISINCLUDE


/*==============================================================================
        KEY DESCRIPTOR - Used by isbuild(), isaddindex(), isstart() and
                         isindexinfo()
==============================================================================*/
#define NPARTS          8

/*----- The Key Descriptor structure -----------------------------------------*/
struct  keypart
{
        short   kp_start;
        short   kp_leng;
        short   kp_type;
};

struct  keydesc
{
                short   k_flags;
                short   k_nparts;
        struct  keypart k_part[NPARTS];
};

/*----- k_flags values -------------------------------------------------------*/
#define ISNODUPS        0x0000          /* duplicates are not allowed */
#define ISDUPS          0x0001          /* duplicates are allowed */
#define DCOMPRESS       0x0002          /* key compression */
#define LCOMPRESS       0x0004          /* key compression */
#define TCOMPRESS       0x0008          /* key compression */
#define COMPRESS        0x000e          /* key compression */

/*----- kp_type values and sizes ---------------------------------------------*/
#define CHARTYPE        0x0000          /* field is CHARTYPE */
#define INTTYPE         0x0001          /* field is INTTYPE */
#define LONGTYPE        0x0002          /* field is LONGTYPE */
#define DOUBLETYPE      0x0003          /* field is DOUBLETYPE */
#define FLOATTYPE       0x0004          /* field is FLOATTYPE */
#define DECIMALTYPE     CHARTYPE        /* field is DECIMALTYPE */
#define ISDESC          0x0080          /* field is descending */

#define CHARSIZE        0x0001          /* length of CHARTYPE item */
#define INTSIZE         0x0002          /* length of INTTYPE item */
#define LONGSIZE        0x0004          /* length of LONGTYPE item */
#define FLOATSIZE       0x0004          /* length of FLOATTYPE item */
#define DOUBLESIZE      0x0008          /* length of DOUBLETYPE item */

#define MAXKEYSIZE      120             /* not used */


/*==============================================================================
        DICTIONARY DESCRIPTOR - Used by isindexinfo
==============================================================================*/

struct  dictinfo
{
        short   di_nkeys;       /* number of user keys */
        short   di_recsize;     /* (maximum) data record size */
        short   di_idxsize;     /* index record length */
        long    di_nrecords;    /* number of data records */
};


/*==============================================================================
        FILE USAGE CONSTANTS
==============================================================================*/
/*----- Used by isopen(), isbuild(), and islock() ----------------------------*/
#define ISINPUT         0x0000          /* input only */
#define ISOUTPUT        0x0001          /* output only */
#define ISINOUT         0x0002          /* input or output */

#define ISAUTOLOCK      0x0200          /* automatic locking/unlocking */
#define ISMANULOCK      0x0400          /* manual locking */
#define ISEXCLLOCK      0x0800          /* exclusive file access */

#define ISMULTLOCK      0x8000          /* automatic locking, no unlock */
#define ISWRITLOCK      0x4000          /* automatic locking on (re)write */
#define ISCOMMIT        ISMULTLOCK
#define ISWLOCK         ISWRITLOCK

/*----- Used by isread() and isstart() ---------------------------------------*/
#define ISFIRST         0x0000          /* first key in current index */
#define ISLAST          0x0001          /* last key in current index */
#define ISNEXT          0x0002          /* next key in current index */
#define ISPREV          0x0003          /* previous key in current index */
#define ISCURR          0x0004          /* current key */
#define ISEQUAL         0x0005          /* key equal to spec value */
#define ISGREAT         0x0006          /* smallest key greater than spec val */
#define ISGTEQ          0x0007          /* smallest key greater/equal spec val*/

#define ISLOCK          0x0100          /* lock record */
#define ISNOLOCK        0x0800          /* internal */


/*==============================================================================
        AUDIT TRAIL
==============================================================================*/

/*----- Commands for isaudit() -----------------------------------------------*/
#define AUDSETNAME      0x0000          /* store pathname in data file */
#define AUDGETNAME      0x0001          /* load pathname from data file */
#define AUDSTART        0x0002          /* start audit trail */
#define AUDSTOP         0x0003          /* stop audit trail */
#define AUDINFO         0x0004          /* audit trail status */

/*----- Overhead struct that preceeds data record in audit trail -------------*/
struct audhead
{
        char    au_type[2];             /* operation type: dd, aa, rr, or ww */
        char    au_time[4];             /* time of operation */
        char    au_procid[2];           /* process id */
        char    au_userid[2];           /* user id */
        char    au_recnum[4];           /* record number */
};

#define AUDHEADSIZE     14


/*==============================================================================
        iserrio VALUES
==============================================================================*/
#define IO_OPEN         0x0010          /* error on open */
#define IO_CREA         0x0020          /* error on create */
#define IO_SEEK         0x0030          /* error on lseek */
#define IO_READ         0x0040          /* error on read */
#define IO_WRIT         0x0050          /* error on write */
#define IO_LOCK         0x0060          /* error on fcntl */
#define IO_IOCTL        0x0070          /* error on ioctl */

#define IO_IDX          0x0001          /* system error on index file */
#define IO_DAT          0x0002          /* system error on data file */
#define IO_AUD          0x0003          /* system error on audit file */
#define IO_LOK          0x0004          /* not used */
#define IO_SEM          0x0005          /* not used */


/*==============================================================================
        iserrno VALUES
==============================================================================*/
#define EDUPL           100             /* duplicate value not allowed */
#define ENOTOPEN        101             /* file not open */
#define EBADARG         102             /* bad argument */
#define EBADKEY         103             /* bad key descriptor format */
#define ETOOMANY        104             /* too many files open */
#define EBADFILE        105             /* bad file format */
#define ENOTEXCL        106             /* must be opened exclusive */
#define ELOCKED         107             /* record locked */
#define EKEXISTS        108             /* key descriptor exists */
#define EPRIMKEY        109             /* can't delete primary key */
#define EENDFILE        110             /* beginning or end of file */
#define ENOREC          111             /* index or key (record) not found */
#define ENOCURR         112             /* currency lost/undefined */
#define EFLOCKED        113             /* file is locked */
#define EFNAME          114             /* file name is too long */
#define ENOLOK          115             /* not used */
#define EBADMEM         116             /* not enough memory */
#define EBADCOLL        117             /* not used */


/*==============================================================================
        DEFINE FUNCTIONS WHICH DO NOT RETURN int VALUES.
==============================================================================*/
        extern long              ldlong();
        extern double            ldfloat();
        extern double            lddbl();

        extern unsigned char    *stint();
        extern unsigned char    *stlong();
        extern unsigned char    *stfloat();
        extern unsigned char    *stdbl();


/*==============================================================================
        GLOBAL VARIABLES AND DEFAULT/INITIAL VALUES.
==============================================================================*/

#ifdef  ISDEFSPACE
        unsigned int     iserrno        = 0;    /* error code */
        unsigned int     iserrio        = 0;    /* error info */
        unsigned char    isstat1        = 0;    /* status byte 1 */
        unsigned char    isstat2        = 0;    /* status byte 2 */

                 char    isversnumber[] = "tisam";
                 char    iscopyright[]  = "tisam";
                 char    isserial[]     = "tisam02.08.8";

        unsigned int     issingleuser   = 0;    /* not used */
        unsigned int     is_nerr        = 117;  /* not used */
                 char   *is_errlist[]   = {"", "", "", "", "", "",
                                           "", "", "", "", "", "",
                                           "", "", "", "", "", ""};
                                                /* not used */
        unsigned long    isrecnum       = 0;    /* record offset */
#else
        extern  unsigned int     iserrno;
        extern  unsigned int     iserrio;
        extern  unsigned char    isstat1;
        extern  unsigned char    isstat2;

        extern           char   *isversnumber;
        extern           char   *iscopyright;
        extern           char   *isserial;

        extern  unsigned int     issingleuser;
        extern  unsigned int     is_nerr;
        extern           char   *is_errlist[];

        extern  unsigned long    isrecnum;
#endif

#ifdef  ISDEFSPACE
        unsigned int     isreclnu       = -1;   /* data bytes desired */
        unsigned int     isreclnr       = 0;    /* data bytes returned */

        unsigned long    iskdid         = 0;    /* unique key id */
        unsigned short   isflage        = 0;    /* tisam k_flage */
        unsigned short   isflagr        = 0;    /* tisam k_flage returned */
        unsigned long    ismode         = 0;    /* tisam default mode */
        unsigned long    isxxisam       = 0L;   /* internal */
#else
        extern  unsigned int     isreclnu;
        extern  unsigned int     isreclnr;

        extern  unsigned long    iskdid;
        extern  unsigned short   isflage;
        extern  unsigned short   isflagr;
        extern  unsigned long    ismode;
        extern  unsigned long    isxxisam;
#endif

#define ISMFISAM        0x00000001L             /* internal */

#endif
lan.h
/*
        (C) COPYRIGHT, TEXAS INSTRUMENTS INCORPORATED, 1985.  ALL
        RIGHTS RESERVED.  PROPERTY OF TEXAS INSTRUMENTS INCORPORATED.
        RESTRICTED RIGHTS - USE, DUPLICATION, OR DISCLOSURE IS SUBJECT
        TO RESTRICTIONS SET FORTH IN TI'S PROGRAM LICENSE AGREEMENT AND
        ASSOCIATED DOCUMENTATION.
 */
/* @(#)lan.h    1.14 91/06/05 */

/*
 *              lan.h
 */

union  addr48 {                 /* definition of 48-bit address */
        char    adr[6];
        unsigned short sadr[3];
};
                                /* Level zero opcode structure definitions */

struct  sOP_reg {               /* register type */
        unsigned short  type;   /* packet type for receive */
        int     handle;         /* returned for receive calls */
        int     lsignal;        /* signal for packet received */
        int     maxtimer;       /* time packets are allowed on queue */
};

struct  sOP_dreg {              /* deregister type */
        unsigned short  type;   /* packet type for receive */
};

struct  sOP_rcv_snd {           /* receive and send packets */
        int     handle;         /* handle for receives */
        int     timout;         /* timeout value */
};


struct  sOP_stat {              /* ethernet statistics */
        int     clear;          /* read/reset flag */
        int     adp;            /* returned adaptor type */
};

struct  sOP_mc_reg_dreg {       /* register/deregister multicast address */
        union addr48 mcaddr;    /* multicast address */
};

struct  sOP_getadr {            /* register/deregister multicast address */
        union addr48 hostaddr;  /* multicast address */
};

struct  sOP_netutil {           /* measure network utilization */
        unsigned long intrvl;   /* interval length in units of 3.2 us */
        unsigned long samples;  /* number of samples */
        unsigned short lev;     /* interrupt level at which to sample */
        unsigned long ncs0;     /* number of samples carrier on for port 0 */
        unsigned long ncs1;     /* number of samples carrier on for port 1 */
};

struct  sOP_nmgr {                      /* name manager request packet */
        unsigned short ethadr[3];       /* ethernet address */
        unsigned long  netadr;          /* network address */
        unsigned short socket;          /* socket (optional) */
        char sname[8];                  /* sitename */
        unsigned short nm_op;           /* nmgr internal op code */
};

struct  s_ethhdr {              /* level zero ethernet header */
        union addr48 dstadr;    /* destination address */
        union addr48 srcadr;    /* source address */
        unsigned short  type;   /* packet type */
};

#define L0HDRLEN (sizeof(struct sL0Head))
#define DUMP_AREA_LEN 170       /* 586 dump area length */

#define ZERO_REG     0          /* register type */
#define ZERO_DEREG   1          /* deregister type */
#define ZERO_SEND    2          /* send packet */
#define ZERO_RCV     3          /* receive packet */
#define ZERO_STAT    4          /* netstat */
#define ZERO_MC_REG  5          /* register multicast address */
#define ZERO_MC_DREG 6          /* deregister multicast address */
#define ZERO_NETUTIL 7          /* network utilization */
#define ZERO_GETADR  8          /* get 48-bit address */
#define ZERO_NM_REQ  9          /* name manager request */
#define ZERO_DUMP   10          /* 586 dump area */

#define MAX_OP       11         /* opcode limit */

                                /* LEVEL ZERO status error codes */

#define NET_OK          0
#define NET_IOERR       1003901
#define NET_BADHAND     1003902
#define NET_BADTYP      1003903
#define NET_TOOBIG      1003904
#define NET_XFRFAIL     1003905
#define NET_TIMOUT      1003906
#define NET_RCVPEND     1003907
#define NET_TRUNCATION  1003908
#define NET_RESERR      1003909
#define NET_NOROOM      1003910
#define NET_NOTREG      1003911
#define NET_INUSE       1003912
#define NET_BADOP       1003913
#define NET_BADMCADR    1003914
#define NET_SPACERR     1003915
#define NET_DUPMC       1003916
#define NET_UNDEFMC     1003917
#define NET_TIMERR      1003918
#define NET_NMNOTACTV   1003964

union   uCMD{
        struct  sOP_reg         OP_reg;
        struct  sOP_dreg        OP_dreg;
        struct  sOP_rcv_snd     OP_rcv_snd;
        struct  sOP_stat        OP_stat;
        struct  sOP_mc_reg_dreg OP_mc_reg_dreg;
        struct  sOP_netutil     OP_netutil;
        struct  sOP_getadr      OP_getadr;
        struct  sOP_nmgr        OP_nmgr;
};

struct  sioctl_head {           /* ioctl fixed header */
        int     size;                   /* size of ioctl buf */
        int     xfer_size;              /* transfer size */
        int     op_code;                /* supplied op_code */
        int     status;                 /* returned status */
};

struct  ioctl_buf {             /* ioctl buffer template */
        struct  sioctl_head ioctl_head;
        union   uCMD cmd;
};

struct  s_netioctl {            /* ioctl buffer template */
        struct  sioctl_head ioctl_head;
        struct  sOP_rcv_snd rcvsnd;
};

struct s_statioctl {            /* net stats command block */
        struct sioctl_head ioctl_head;
        struct sOP_stat opstat;
};

#define IOCTL_HEADER_SIZE (sizeof (struct sioctl_head))
#define IOCTL_UNION_SIZE  (sizeof (struct ioctl_buf))
#define ZEROREG_SIZE   (IOCTL_HEADER_SIZE + sizeof(struct sOP_reg))
#define ZERODREG_SIZE  (IOCTL_HEADER_SIZE + sizeof(struct sOP_dreg))
#define ZEROXFER_SIZE  (IOCTL_HEADER_SIZE + sizeof(struct sOP_rcv_snd))
#define ZEROSTAT_SIZE  (IOCTL_HEADER_SIZE + sizeof(struct sOP_stat))
#define ZEROMCRD_SIZE  (IOCTL_HEADER_SIZE + sizeof(struct sOP_mc_reg_dreg))
#define ZERONUTL_SIZE  (IOCTL_HEADER_SIZE + sizeof(struct sOP_netutil))
#define ZEROGADR_SIZE  (IOCTL_HEADER_SIZE + sizeof(struct sOP_getadr))
#define ZERONMGR_SIZE  (IOCTL_HEADER_SIZE + sizeof(struct sOP_nmgr))
#define ZERODUMP_SIZE  IOCTL_HEADER_SIZE

#define ADP_IEEE_802    0x77
#define ADP_STARLAN     0x78
#define ADP_V35         0x79
#define ADP_NONE        0x7f

ldfcn.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)ldfcn.h      1.2 86/07/01";
*/
/*      @(#)ldfcn.h     2.2 2/28/83     */

/*
 *      The following two declarations appear in the IH versions of
 *      "stdio.h" but do not appear in the normal 1.2 versions.
 */

long ftell();
char *fgets();

#ifndef LDFILE
struct  ldfile {
        int     _fnum_;         /* so each instance of an LDFILE is unique */
        FILE    *ioptr;         /* system I/O pointer value */
        long    offset;         /* absolute offset to the start of the file */
        FILHDR  header;         /* the file header of the opened file */
        unsigned short  type;           /* indicator of the type of the file */
};


/*
        provide a structure "type" definition, and the associated
        "attributes"
*/

#define LDFILE          struct ldfile
#define IOPTR(x)        x->ioptr
#define OFFSET(x)       x->offset
#define TYPE(x)         x->type
#define HEADER(x)       x->header
#define LDFSZ           sizeof(LDFILE)

/*
        define various values of TYPE(ldptr)
*/

#define ARTYPE  0177545
#define USH_ARTYPE      (unsigned short)ARTYPE          /***  bs1500  **/

/*
        define symbolic positioning information for FSEEK (and fseek)
*/

#define BEGINNING       0
#define CURRENT         1
#define END             2

/*
        define a structure "type" for an archive header
*/

typedef struct
{
        char ar_name[16];
        long ar_date;
        int ar_uid;
        int ar_gid;
        long ar_mode;
        long ar_size;
} archdr;

#define ARCHDR  archdr
#define ARCHSZ  sizeof(ARCHDR)


/*
        define some useful symbolic constants
*/

#define SYMTBL  0       /* section nnumber and/or section name of the Symbol Table */

#define SUCCESS  1
#define CLOSED   1
#define FAILURE  0
#define NOCLOSE  0
#define BADINDEX        -1L

#define OKFSEEK 0

/*
        define macros to permit the direct use of LDFILE pointers with the
        standard I/O library procedures
*/

LDFILE *ldopen();
LDFILE *ldaopen();

#define GETC(ldptr)     getc(IOPTR(ldptr))
#define GETW(ldptr)     getw(IOPTR(ldptr))
#define FEOF(ldptr)     feof(IOPTR(ldptr))
#define FERROR(ldptr)   ferror(IOPTR(ldptr))
#define FGETC(ldptr)    fgetc(IOPTR(ldptr))
#define FGETS(s,n,ldptr)        fgets(s,n,IOPTR(ldptr))
#define FILENO(ldptr)   fileno(IOPTR(ldptr))
#define FREAD(p,s,n,ldptr)      fread(p,s,n,IOPTR(ldptr))
#define FSEEK(ldptr,o,p)        fseek(IOPTR(ldptr),(p==BEGINNING)?(OFFSET(ldptr)+o):o,p)
#define FTELL(ldptr)    ftell(IOPTR(ldptr))
#define FWRITE(p,s,n,ldptr)       fwrite(p,s,n,IOPTR(ldptr))
#define REWIND(ldptr)   rewind(IOPTR(ldptr))
#define SETBUF(ldptr,b) setbuf(IOPTR(ldptr),b)
#define UNGETC(c,ldptr)         ungetc(c,IOPTR(ldptr))
#define STROFFSET(ldptr)        (HEADER(ldptr).f_symptr + HEADER(ldptr).f_nsyms * 18) /* 18 == SYMESZ */
#endif
linenum.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)linenum.h    1.1 86/05/15";
*/
/*      @(#)linenum.h   2.1     */
/*  There is one line number entry for every
    "breakpointable" source line in a section.
    Line numbers are grouped on a per function
    basis; the first entry in a function grouping
    will have l_lnno = 0 and in place of physical
    address will be the symbol table index of
    the function name.
*/
struct lineno
{
        union
        {
                long    l_symndx ;      /* sym. table index of function name
                                                iff l_lnno == 0      */
                long    l_paddr ;       /* (physical) address of line number */
        }               l_addr ;
        unsigned short  l_lnno ;        /* line number */
} ;

#define LINENO  struct lineno
#define LINESZ  6       /* sizeof(LINENO) */
macros.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)macros.h     1.1 86/05/15";
*/
/*      @(#)macros.h    1.1     */
/*
        numeric() is useful in while's, if's, etc., but don't use *p++
        max() and min() depend on the types of the operands
        abs() is absolute value
*/
# define numeric(c)             (c >= '0' && c <= '9')
# define max(a,b)               (a<b ? b : a)
# define min(a,b)               (a>b ? b : a)
# define abs(x)                 (x>=0 ? x : -(x))

# define copy(srce,dest)        cat(dest,srce,0)
# define compare(str1,str2)     strcmp(str1,str2)
# define equal(str1,str2)       !strcmp(str1,str2)
# define length(str)            strlen(str)
# define size(str)              (strlen(str) + 1)

/*
        The global variable Statbuf is available for use as a stat(II)
        structure.  Note that "stat.h" is included here and should
        not be included elsewhere.
        Exists(file) returns 0 if the file does not exist;
        the flags word if it does (the flags word is always non-zero).
*/
# include "sys/stat.h"
extern struct stat Statbuf;
# define exists(file)           (stat(file,&Statbuf)<0 ? 0:Statbuf.st_mode)

extern long itol();
/*
        libS.a interface for xopen() and xcreat()
*/
# define xfopen(file,mode)      fdfopen(xopen(file,mode),mode)
# define xfcreat(file,mode)     fdfopen(xcreat(file,mode),1)

# define remove(file)           xunlink(file)

/*
        SAVE() and RSTR() use local data in nested blocks.
        Make sure that they nest cleanly.
*/
# define SAVE(name,place)       { int place = name;
# define RSTR(name,place)       name = place;}

/*
        Use: DEBUG(sum,d) which becomes fprintf(stderr,"sum = %d\n",sum)
*/
# define DEBUG(variable,type)   fprintf(stderr,"variable = %type\n",variable)

/*
        Use: SCCSID(@(#)macros.h        1.1) which becomes static char Sccsid "@(#)macros.h     1.1"
*/
# define SCCSID(arg)            static char Sccsid[]="arg"

/*
        Use of ERRABORT() will cause libS.a internal
        errors to cause aborts
*/
# define ERRABORT()     _error() { abort(); }

/*
        Use of USXALLOC() is required to force all calls to alloc()
        (e.g., from libS.a) to call xalloc().
*/
# define USXALLOC() \
                char *alloc(n) {return((char *)xalloc((unsigned)n));} \
                free(n) char *n; {xfree(n);} \
                char *malloc(n) unsigned n; {int p; p=xalloc(n); \
                        return((char *)(p != -1?p:0));}

# define NONBLANK(p)            while (*p==' ' || *p=='\t') p++


/*
        A global null string.
*/
extern char     Null[1];

/*
        A global error message string.
*/
extern char     Error[128];
mallint.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)mallint.h    1.1 86/05/15";
*/

/*      @(#)mallint.h   1.1     */
/*
        template for the header
*/
struct header {
        struct header *nextblk;
        struct header *nextfree;
        struct header *prevfree;
#ifdef  pdp11
        struct header *dummy;      /* pad to a multple of 4 bytes */
#endif
};
/*
        template for a small block
*/
struct lblk  {
        union {
                struct lblk *nextfree;  /* the next free little block in this
                                           holding block.  This field is used
                                           when the block is free */
                struct holdblk *holder; /* the holding block containing this
                                           little block.  This field is used
                                           when the block is allocated */
        }  header;
        char byte;                  /* There is no telling how big this
                                           field freally is.  */
};
/*
        template for holding block
*/
struct holdblk {
        struct holdblk *nexthblk;   /* next holding block */
        struct holdblk *prevhblk;   /* previous holding block */
        struct lblk *lfreeq;    /* head of free queue within block */
        struct lblk *unused;    /* pointer to 1st little block never used */
        int blksz;              /* size of little blocks contained */
#ifdef pdp11
        int pad;                /* pad to an even # of words */
#endif
        char space[1];          /* start of space to allocate.
                                   This must be on a word boundary */
};

/*
        The following manipulate the free queue

                DELFREEQ will remove x from the free queue
                ADDFREEQ will add an element to the head
                         of the free queue.
                MOVEHEAD will move the free pointers so that
                         x is at the front of the queue
*/
#define ADDFREEQ(x)       (x)->prevfree = &(freeptr[0]);\
                                (x)->nextfree = freeptr[0].nextfree;\
                                freeptr[0].nextfree->prevfree = (x);\
                                freeptr[0].nextfree = (x);\
                                assert((x)->nextfree != (x));\
                                assert((x)->prevfree != (x));
#define DELFREEQ(x)       (x)->prevfree->nextfree = (x)->nextfree;\
                                (x)->nextfree->prevfree = (x)->prevfree;\
                                assert((x)->nextfree != (x));\
                                assert((x)->prevfree != (x));
#define MOVEHEAD(x)       freeptr[1].prevfree->nextfree = \
                                        freeptr[0].nextfree;\
                                freeptr[0].nextfree->prevfree = \
                                        freeptr[1].prevfree;\
                                (x)->prevfree->nextfree = &(freeptr[1]);\
                                freeptr[1].prevfree = (x)->prevfree;\
                                (x)->prevfree = &(freeptr[0]);\
                                freeptr[0].nextfree = (x);\
                                assert((x)->nextfree != (x));\
                                assert((x)->prevfree != (x));
/*
        The following manipulate the busy flag
*/
#define BUSY    1
#define SETBUSY(x)      ((struct header *)((int)(x) | BUSY))
#define CLRBUSY(x)      ((struct header *)((int)(x) & ~BUSY))
#define TESTBUSY(x)     ((int)(x) & BUSY)
/*
        The following manipulate the small block flag
*/
#define SMAL    2
#define SETSMAL(x)      ((struct lblk *)((int)(x) | SMAL))
#define CLRSMAL(x)      ((struct lblk *)((int)(x) & ~SMAL))
#define TESTSMAL(x)     ((int)(x) & SMAL)
/*
        The following manipulate both flags.  They must be
        type coerced
*/
#define SETALL(x)       ((int)(x) | (SMAL | BUSY))
#define CLRALL(x)       ((int)(x) & ~(SMAL | BUSY))
/*
        Other useful constants
*/
#define TRUE    1
#define FALSE   0
#define HEADSZ  sizeof(struct header)   /* size of unallocated block header */
/*      MINHEAD is the minimum size of an allocated block header */
#ifdef pdp11
#define MINHEAD 4
#else
#define MINHEAD sizeof(struct header *)
#endif
#define MINBLKSZ 12             /* min. block size must as big as
                                   HEADSZ */
#define BLOCKSZ 2048            /* memory is gotten from sbrk in
                                   multiples of BLOCKSZ */
#define GROUND  (struct header *)0
#define LGROUND (struct lblk *)0        /* ground for a queue within a holding
                                           block        */
#define HGROUND (struct holdblk *)0     /* ground for the holding block queue */
/* number of bytes to align to  (must be at least 4, because lower 2 bits
   are used for flags */
#define ALIGNSZ 4
#ifndef NULL
#define NULL    (char *)0
#endif
/*
        Structures and constants describing the holding blocks
*/
#define NUMLBLKS  100   /* default number of small blocks per holding block */
/* size of a holding block with small blocks of size blksz */
#define HOLDSZ(blksz)  (sizeof(struct holdblk) - sizeof(int) + blksz*numlblks)
#ifndef pdp11
#define FASTCT    6       /* default number of block sizes that can be
                                   allocated quickly */
#else
#define FASTCT 0
#endif
#define MAXFAST   ALIGNSZ*FASTCT  /* default maximum size block for fast
                                     allocation */


#ifdef debug
#define CHECKQ  checkq();
static
checkq()
{
        register struct header *p;

        p = &(freeptr[0]);
        /* check forward */
        while(p != &(freeptr[1]))       {
                p = p->nextfree;
                assert(p->prevfree->nextfree == p);
        }
        /* check backward */
        while(p != &(freeptr[0]))       {
                p = p->prevfree;
                assert(p->nextfree->prevfree == p);
        }
}
#else
#define CHECKQ
#endif

malloc.h
/* --------------------------------------------------------------------------
   COPYRIGHT (c) 1990   TEXAS INSTRUMENTS INCORPORATED   ALL RIGHTS RESERVED
  --------------------------------------------------------------------------- */
/*
#ident "@(#)malloc.h    1.2 90/11/28"
*/
/*      @(#)malloc.h    1.2     */

/*
        Constants defining mallopt operations
*/
#define M_MXFAST        1       /* set size of blocks to be fast */
#define M_NLBLKS        2       /* set number of block in a holding block */
#define M_GRAIN         3       /* set number of sizes mapped to one, for
                                   small blocks */
#define M_KEEP          4       /* retain contents of block after a free until
                                   another allocation */
/*
        structure filled by
*/
struct mallinfo  {
        int arena;      /* total space in arena */
        int ordblks;    /* number of ordinary blocks */
        int smblks;     /* number of small blocks */
        int hblks;      /* number of holding blocks */
        int hblkhd;     /* space in holding block headers */
        int usmblks;    /* space in small blocks in use */
        int fsmblks;    /* space in free small blocks */
        int uordblks;   /* space in ordinary blocks in use */
        int fordblks;   /* space in free ordinary blocks */
        int keepcost;   /* cost of enabling keep option */
};

#ifndef _MALLOC_FUNC
#define _MALLOC_FUNC
extern char *malloc();
extern void free();
extern char *realloc();
#endif
extern int mallopt();
extern struct mallinfo mallinfo();
math.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)math.h       1.1 86/05/15";
*/
/*      @(#)math.h      2.5     */
#ifndef _POLY9
extern int errno, signgam;

extern double atof(), frexp(), ldexp(), modf();
extern double j0(), j1(), jn(), y0(), y1(), yn();
extern double erf(), erfc();
extern double exp(), log(), log10(), pow(), sqrt();
extern double floor(), ceil(), fmod(), fabs();
extern double gamma();
extern double hypot();
extern int matherr();
extern double sinh(), cosh(), tanh();
extern double sin(), cos(), tan(), asin(), acos(), atan(), atan2();

/* some useful constants */
#define M_E     2.7182818284590452354
#define M_LOG2E 1.4426950408889634074
#define M_LOG10E        0.43429448190325182765
#define M_LN2   0.69314718055994530942
#define M_LN10  2.30258509299404568402
#define M_PI    3.14159265358979323846
#define M_PI_2  1.57079632679489661923
#define M_PI_4  0.78539816339744830962
#define M_1_PI  0.31830988618379067154
#define M_2_PI  0.63661977236758134308
#define M_2_SQRTPI      1.12837916709551257390
#define M_SQRT2 1.41421356237309504880
#define M_SQRT1_2       0.70710678118654752440
#if u3b || u3b5 || m68k
#define MAXFLOAT        ((float)3.40282346638528860e+38)
#endif
#if pdp11 || vax
#define MAXFLOAT        ((float)1.701411733192644299e+38)
#endif
#if gcos
#define MAXFLOAT        ((float)1.7014118219281863150e+38)
#endif
#define HUGE    MAXFLOAT

#define _ABS(x) ((x) < 0 ? -(x) : (x))
#define _REDUCE(TYPE, X, XN, C1, C2)    { \
        double x1 = (double)(TYPE)X, x2 = X - x1; \
        X = x1 - (XN) * (C1); X += x2; X -= (XN) * (C2); }
#define _POLY1(x, c)    ((c)[0] * (x) + (c)[1])
#define _POLY2(x, c)    (_POLY1((x), (c)) * (x) + (c)[2])
#define _POLY3(x, c)    (_POLY2((x), (c)) * (x) + (c)[3])
#define _POLY4(x, c)    (_POLY3((x), (c)) * (x) + (c)[4])
#define _POLY5(x, c)    (_POLY4((x), (c)) * (x) + (c)[5])
#define _POLY6(x, c)    (_POLY5((x), (c)) * (x) + (c)[6])
#define _POLY7(x, c)    (_POLY6((x), (c)) * (x) + (c)[7])
#define _POLY8(x, c)    (_POLY7((x), (c)) * (x) + (c)[8])
#define _POLY9(x, c)    (_POLY8((x), (c)) * (x) + (c)[9])

struct exception {
        int type;
        char *name;
        double arg1;
        double arg2;
        double retval;
};

#define DOMAIN          1
#define SING            2
#define OVERFLOW        3
#define UNDERFLOW       4
#define TLOSS           5
#define PLOSS           6
#endif
memory.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)memory.h     1.1 86/05/15";
*/
/*      @(#)memory.h    1.2     */
extern char
        *memccpy();
#ifndef _MEM_FUNC
#define _MEM_FUNC
extern char
        *memchr(),
        *memcpy(),
        *memset();
extern int memcmp();
#endif
mnttab.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)mnttab.h     1.2 87/12/10";
*/
/*      @(#)mnttab.h    1.2     */
/*      3.0 SID #       1.1     */
#define NMOUNT  256

/* Format of the /etc/mnttab file which is set by the mount(1m)
 * command
 */
struct mnttab {
        char    mt_dev[32],
                mt_filsys[32];
                short   mt_ro_flg;
        time_t  mt_time;
};
mon.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)mon.h        1.1 86/05/15";
*/
/*      @(#)mon.h       1.6     */
struct hdr {
        char    *lpc;
        char    *hpc;
        int     nfns;
};

struct cnt {
        char    *fnpc;
        long    mcnt;
};

typedef unsigned short WORD;

#define MON_OUT "mon.out"
#ifdef m68k
#define MPROGS0 (300 * sizeof(WORD))    /* We want 600!!! */
#else
#define MPROGS0 (150 * sizeof(WORD))    /* 300 for pdp11, 600 for 32-bits */
#endif
#define MSCALE0 4
#define NULL    0
nan.h
/*      Copyright (c) 1984 AT&T */
/*        All Rights Reserved   */

/*      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T     */
/*      The copyright notice above does not evidence any        */
/*      actual or intended publication of such source code.     */
/* --------------------------------------------------------------------------
   COPYRIGHT (c) 1990   TEXAS INSTRUMENTS INCORPORATED   ALL RIGHTS RESERVED
  --------------------------------------------------------------------------- */

#ident  "@(#)nan.h      1.5 91/03/19"
/* Handling of Not_a_Number's (only in IEEE floating-point standard) */
#if _IEEE

#ifndef MAXFLOAT
#include <values.h>
#endif

typedef union
{
        double  d;
        long    l[2];
} dnan;

        /* IsNANorINF checks that exponent of double == 2047 *
         * i.e. that number is a NaN or an infinity          */

#define IsNANorINF(X)  ((((dnan *)&(X))->l[0] & 0x7FF00000) == 0x7FF00000)

        /* IsINF must be used after IsNANorINF          *
         * has checked the exponent                     */

#define IsINF(X)  ((((dnan *)&(X))->l[0] & 0xFFFFF) == 0 &&  \
                    ((dnan *)&(X))->l[1] == 0)

        /* IsPosNAN and IsNegNAN can be used            *
         * to check the sign of infinities too          */

#define IsPosNAN(X)  ((((dnan *)&(X))->l[0] & 0x80000000) == 0)

#define IsNegNAN(X)  ((((dnan *)&(X))->l[0] & 0x80000000) != 0)

        /* GETNaNPC gets the leftmost 32 bits           *
         * of the fraction part                         */

#define GETNaNPC(dval)   ((((dnan *)&(dval))->l[0] & 0xFFFFF) << 12 | \
                           ((dnan *)&(dval))->l[1] >> 20)

#define KILLFPE()       (void) kill(getpid(), 8)
#define NaN(X)          (IsNANorINF(X) && !IsINF(X))
#define KILLNaN(X)      if (NaN(X)) KILLFPE()
#define ChkNaNINF(X)    if (IsNANorINF(X)) \
                            if (IsINF(X)) \
                                X = IsPosNAN(X) ? MAXFLOAT : -MAXFLOAT; \
                            else \
                                KILLFPE()

#else

typedef double dnan;
#define IsINF(X)   0
#define IsPINF(X)  0
#define IsNegNAN(X)  0
#define IsPosNAN(X)  0
#define IsNAN(X)   0
#define GETNaNPC(X)   0L

#define NaN(X)  0
#define KILLNaN(X)
#endif
netstat.h
/*
   COPYRIGHT (c) 1991 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = "@(#)netstat.h   1.1 (TI) 91/05/01";
*/

/*
 * Special netstat.h file to include the new sys/netstat.h file.
 */

#include <sys/netstat.h>
nlist.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)nlist.h      1.1 86/05/15";
*/
/*
*       "@(#) nlist.h: 1.2 3/19/83"
*/

#if vax || u3b || u3b5 || m68k

/* symbol table entry structure */

struct nlist
{
        char            *n_name;        /* symbol name */
        long            n_value;        /* value of symbol */
        short           n_scnum;        /* section number */
        unsigned short  n_type;         /* type and derived type */
        char            n_sclass;       /* storage class */
        char            n_numaux;       /* number of aux. entries */
};

#else /* pdp11 || u370 */

struct nlist
{
        char            n_name[8];      /* symbol name */
#if pdp11
        int             n_type;         /* type of symbol in .o */
#else
        char            n_type;
        char            n_other;
        short           n_desc;
#endif
        unsigned        n_value;        /* value of symbol */
};

#endif
nsaddr.h
/*      Copyright (c) 1984 AT&T */
/*        All Rights Reserved   */

/*      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T     */
/*      The copyright notice above does not evidence any        */
/*      actual or intended publication of such source code.     */
/* --------------------------------------------------------------------------
   COPYRIGHT (c) 1990   TEXAS INSTRUMENTS INCORPORATED   ALL RIGHTS RESERVED
  --------------------------------------------------------------------------- */

#ident  "@(#)nsaddr.h   1.2 90/11/28"
/*
        stoa - convert string to address

        atos - convert address to string

        header file
*/


#define OCT     0       /* octal type */
#define HEX     1       /* hexadecimal type */
#define RAW     2       /* string type */
#define KEEP    8       /* keep protocol field  */

struct address {
        char            *protocol;
        struct netbuf   addbuf;
};

struct netbuf   *stoa(/* str, netbuf */);
char            *atos(/* str, netbuf, type */);
struct address  *astoa(/* str, addr */);
char            *aatos(/* str, addr, type */);
nserve.h
/*
   COPYRIGHT (c) 1989 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)nserve.h     1.2 90/06/22";
*/
/*      Copyright (c) 1984 AT&T */
/*        All Rights Reserved   */

/*      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T     */
/*      The copyright notice above does not evidence any        */
/*      actual or intended publication of such source code.     */

#include <sys/nserve.h>
/*
 *
 *      name server header file.  contains defines necessary for
 *      any program that wants to talk with the name server.
 *
 */
#define NSVERSION       1       /* coincides with load n7 SVR3          */

/*
 * Pathname defines:
 * NSDIRQ and NSDEV are set up to be combined with other #defines
 * The missing trailing quote (") on these defines is correct, as are the
 * missing leading quotes on the other defines in this group.
 * NOTE: don't put a comment after the NSDIRQ or NSDEV defines.
 */
/* Another NOTE: GNU C preprocessor/compiler don't handle the second half
 * of the #defines very well (preprocessor includes the comment in the
 * expansion, compiler doesn't parse comments). Placing the comments on a
 * separate line gets around the problem.
 */

#define NSDEV     "/usr/nserve
#define NSDIRQ    "/usr/nserve
#define NSPID     NSDEV/nspid"
                                   /* lock file for ns, also has pid    */
#define NS_PIPE   NSDEV/nspip"
                                   /* stream pipe for ns                */
#define NSDIR     NSDIRQ"
                                   /* name server working directory.    */
#define NETMASTER NSDIRQ/rfmaster"
                                   /* master file for nudnix network    */
#define DOMMASTER NSDIRQ/dom.master"
                                   /* file for outside domains          */
#define SAVEDB    NSDIRQ/save.db"
                                   /* saves database when ns exits      */
#define PASSFILE  NSDIRQ/loc.passwd"
                                   /* location of local passwd          */
#define VERPASSWD NSDIRQ/verify/%s/passwd"
                                   /* passwd for verification           */
#define DOMPASSWD NSDIRQ/auth.info/%s/passwd"
                                   /* passwd for dom  "%s"              */
                                   /* contains the domain name.         */
#define NSDOM     NSDIRQ/domain"
                                   /* place to save domain name         */

/* other defines        */
#define PRIMENAME "PRIMARY"     /* default name for unknown primary     */
#define CORRECT   "correct"     /* message stating password is correct  */
#define INCORRECT "sorry"       /* message stating password is wrong    */
#define ADVFILE   "/etc/advtab"
#define TEMPADV   "/etc/tmpadv"
#define REC_TIME  10

/* sizes        */

#define SZ_RES  14      /* maximum size of resource name                     */
#define SZ_MACH 9       /* maximum size of machine name.                     */
#define SZ_PATH 64      /* size of "pathname" of resource                    */
#define SZ_DESC 32      /* size of description                               */
#define SZ_DELEMENT 14  /* max size of one element of a domain name          */

/* types        */
#define FILE_TREE 1     /* sharable file tree   */

/* flags        */
#define READONLY  1
#define READWRITE 2

/* command types        */
#define NS_SNDBACK      0       /* actually a "null" type       */
#define NS_ADV          1       /* advertise a resource         */
#define NS_UNADV        2       /* unadvertise a resource       */
#define NS_GET          3       /* unused query                 */
#define NS_QUERY        4       /* query by name and type.      */
#define NS_INIT         5       /* called to setup name service */
#define NS_SENDPASS     7       /* register passwd w/ primary   */
#define NS_VERIFY       8       /* verify validity of your pwd  */
#define NS_MODADV       9       /* modify an advertisement      */
#define NS_BYMACHINE    10      /* inv query by owner and type  */
#define NS_IQUERY       11      /* general inverse query        */
#define NS_IM_P         12      /* I am primary poll            */
#define NS_IM_NP        13      /* I am secondary poll          */
#define NS_FINDP        14      /* find which machine is prime  */
#define NS_REL          15      /* relinquish being primary     */

/* return codes */
#define FAILURE         0
#define SUCCESS         1
#define MORE_DATA       2       /* or'ed into return when more coming */

/* error codes returned by the name server                      */

#define R_NOERR  0      /* no error                             */
#define R_FORMAT 1      /* format error                         */
#define R_NSFAIL 2      /* name server failure                  */
#define R_NONAME 3      /* name does not exist                  */
#define R_IMP    4      /* request type not implemented or bad  */
#define R_PERM   5      /* no permission for this operation     */
#define R_DUP    6      /* name not unique (for advertise)      */
#define R_SYS    7      /* a system call failed in name server  */
#define R_EPASS  8      /* error accessing primary passwd file  */
#define R_INVPW  9      /* invalid password                     */
#define R_NOPW   10     /* no passwd in primary passwd file     */
#define R_SETUP  11     /* error in ns_setup()                  */
#define R_SEND   12     /* error in ns_send()                   */
#define R_RCV    13     /* error in ns_rcv()                    */
#define R_INREC  14     /* in recovery, try again               */
#define R_FAIL   15     /* unknown failure                      */

/* name server request structure        */

struct nssend {
        short   ns_code;        /* request code (e.g., NS_ADV)  */
        short   ns_type;        /* type of data, unused for now */
        short   ns_flag;        /* read/write flag              */
        char    *ns_name;       /* name of resource             */
        char    *ns_desc;       /* description of resource      */
        char    *ns_path;       /* local pathname of resource   */
        struct address  *ns_addr; /* address of resource's owner*/
        char    **ns_mach;      /* list of client machines      */
};

/* function declarations        */

int     ns_setup();
int     ns_close();
int     ns_send();
struct nssend   *ns_rcv();

/* macros       */
#define SET_NODELAY(f)  fcntl(f,F_SETFL,fcntl(f,F_GETFL,0)|O_NDELAY)
#define CLR_NODELAY(f)  fcntl(f,F_SETFL,fcntl(f,F_GETFL,0)&~O_NDELAY)
pn.h
/*
   COPYRIGHT (c) 1989 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)pn.h 1.1 89/08/17";
*/
/*      Copyright (c) 1984 AT&T */
/*        All Rights Reserved   */

/*      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T     */
/*      The copyright notice above does not evidence any        */
/*      actual or intended publication of such source code.     */


/* switch table structure */

typedef struct {
        char *sw_opcode;        /* opcode */
        int sw_idx;             /* index */
} pntab_t;

#define RFS 105                 /* for rfsdaemon */

#define NUMSWENT 3              /* the number of entries in sw_tab */

/* these are the indicies into sw_tab.
   note that the orders must match the opcodes */

#define RF_RF 0                 /* remote file service */
#define RF_NS 1                 /* name service */
#define RF_AK 2                 /* acknowledgement */

#define NUMDUENT 1              /* the number of entries in du_tab */

/* these are the indicies into du_tab.
   note that the orders must match the opcodes */

#define MNT 0                   /* mount case */

#define PASSWDLEN       20              /* length of password */
#define C_RETRY         2               /* command retry count */
#define DEVSTR          "/dev/%s"
#define LISTNMSG        "NLPS:000:001:%d"
#define CANONSTR        "c4ll"          /* canonical pntab */
#define CANON_CLEN      16              /* canonical length of pntab */
#define OPCODLEN        4               /* 3 chars + null */

/* negotiate data packect */

typedef struct {
        long n_hetero;          /* heterogeneity indication */
        char n_passwd[PASSWDLEN];       /* password */
        struct token n_token;   /* client's token */
        char n_netname[MAXDNAME];       /* netnodename */
} ndata_t;

typedef struct {
        char pn_op[OPCODLEN];
        long pn_lo;
        long pn_hi;
} pnhdr_t;

/* these version numbers specify compatibility between
        different versions of protocol negotiations */

#define LO_VER  1               /* lo version of this library */
#define HI_VER  1               /* hi version of this library */

/* these are the flags for the negotiate routine */

#define SERVER  0
#define CLIENT  1

#define TIMOD   "timod"
poll.h
/*
   COPYRIGHT (c) 1990 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = "@(#)poll.h      1.1 90/01/05";
*/
/*      @(#)poll.h      1.1     */
/*      3.0 SID #       1.1     */
/*
 * Stream header file
 */

#include <sys/poll.h>
printm.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)printm.h     1.1 86/05/15";
*/

#define MAXKEYS  31

typedef struct  {   /*  node to direct b-tree search   */
        short  level ;
        short  max   ;
        long   myloc ;
        long   keys[MAXKEYS]  ;
        long   locn[MAXKEYS]  ;
        }  NODE ;


#define NZ   sizeof(NODE)
prmode.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)prmode.h     1.2 88/02/29";
*/

/* print various r,w,x permissions */

/*              this file requires the  <sys/stat.h>  header  <------
                                and the <sys/inode.h> header  <------     */
prmode(aflag,xflag)
short  aflag,xflag ;
{
/* these arrays are declared static to allow initializations */
static int
        m0[] = { 1,   S_IREAD     ,  'r', '-' },  /*  owner permissions  */
        m1[] = { 1,   S_IWRITE    ,  'w', '-' },
        m2[] = { 3,   S_ISUID
                     |S_IEXEC     ,  's',
                      S_IEXEC     ,  'x',
                      S_ISUID     ,  'S', '-' },
        m3[] = { 1,   S_IREAD >>3 ,  'r', '-' },  /*  group permissions  */
        m4[] = { 1,   S_IWRITE>>3 ,  'w', '-' },
        m5[] = { 3,   S_ISGID
                     |S_IEXEC >>3 ,  's',
                      S_IEXEC >>3 ,  'x',
                      S_ISGID     ,  'l', '-' },
        m6[] = { 1,   S_IREAD >>6 ,  'r', '-' },  /*  other's permissions  */
        m7[] = { 1,   S_IWRITE>>6 ,  'w', '-' },
        m8[] = { 3,   S_ISVTX
                     |S_IEXEC >>6 ,  't',
                      S_IEXEC >>6 ,  'x',
                      S_ISVTX     ,  'T', '-'},

        *m[] = { m0, m1, m2, m3, m4, m5, m6, m7, m8};

register int **mp;

for (mp = &m[0]; mp < &m[sizeof(m)/sizeof(m[0])];) select(*mp++,aflag);
if( xflag&IFORCED ) putchar ('f');
  else              putchar (' ');
}

select(pairp,aflag)                     /*  only call is from pmode   */
register int *pairp, aflag;
{
register int n;

        n = *pairp++;
        while (n-->0) {
                if((aflag & *pairp) == *pairp) { pairp++; break; }
                 else                          { pairp += 2; }
        }
        putchar(*pairp);
}
prof.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)prof.h       1.1 86/05/15";
*/
/*      @(#)prof.h      1.3     */
#ifndef MARK
#define MARK(L) {}
#else
#undef MARK
#ifdef vax
#define MARK(L) {\
                asm("   .data");\
                asm("   .align  4");\
                asm(".L.:");\
                asm("   .long   0");\
                asm("   .text");\
                asm("M.L:");\
                asm("   nop;nop");\
                asm("   movab   .L.,r0");\
                asm("   jsb     mcount");\
                }
#endif
#ifdef u3b
#define MARK(L) {\
                asm("   .data");\
                asm("   .align  4");\
                asm(".L.:");\
                asm("   .word   0");\
                asm("   .text");\
                asm("M.L:");\
                asm("   movw    &.L.,%r0");\
                asm("   jsb     _mcount");\
                }
#endif
#ifdef pdp11
#define MARK(L) {\
                asm("   .bss");\
                asm(".L.:");\
                asm("   .=.+2");\
                asm("   .text");\
                asm("M.L:");\
                asm("   mov     $.L.,r0");\
                asm("   jsr     pc,mcount");\
                }
#endif
#endif
pwd.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)pwd.h        1.1 86/05/15";
*/
/*      @(#)pwd.h       1.1     */
/*      3.0 SID #       1.2     */
struct passwd {
        char    *pw_name;
        char    *pw_passwd;
        int     pw_uid;
        int     pw_gid;
        char    *pw_age;
        char    *pw_comment;
        char    *pw_gecos;
        char    *pw_dir;
        char    *pw_shell;
};

struct comment {
        char    *c_dept;
        char    *c_name;
        char    *c_acct;
        char    *c_bin;
};
regexp.h
/*
   Copyright (c) 1990 Texas Instruments, Incorporated. All Rights Reserved.
*/

/*      Copyright (c) 1984 AT&T */
/*        All Rights Reserved   */

/*      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T     */
/*      The copyright notice above does not evidence any        */
/*      actual or intended publication of such source code.     */

/*
static char *sccs_id = " @(#)regexp.h   1.6 91/12/18 ";
*/

#define CBRA    2
#define CCHR    4
#define CDOT    8
#define CCL     12
#define CXCL    16
#define CDOL    20
#define CCEOF   22
#define CKET    24
#define CBACK   36
#define NCCL    40

#define STAR    01
#define RNGE    03

#define NBRA    9

#define PLACE(c)        ep[c >> 3] |= bittab[c & 07]
#define ISTHERE(c)      (ep[c >> 3] & bittab[c & 07])
#define ecmp(s1, s2, n) (!strncmp(s1, s2, n))

static char     *braslist[NBRA];
static char     *braelist[NBRA];
static int      ebra;
int     sed, nbra;
char    *loc1, *loc2, *locs;
static int      nodelim;

int     circf;
static int      low;
static int      size;

static char     bittab[] = { 1, 2, 4, 8, 16, 32, 64, 128 };

char *
compile(instring, ep, endbuf, seof)
register char *ep;
char *instring, *endbuf;
{
        INIT    /* Dependent declarations and initializations */
        register c;
        register eof = seof;
        char *lastep = instring;
        int cclcnt;
        char bracket[NBRA], *bracketp;
        int closed;
        int neg;
        int lc;
        int i, cflg;
        int iflag; /* used for non-ascii characters in brackets */

        lastep = 0;
        if((c = GETC()) == eof || c == '\n') {
                if(c == '\n') {
                        UNGETC(c);
                        nodelim = 1;
                }
                if(*ep == 0 && !sed)
                        ERROR(41);
                RETURN(ep);
        }
        bracketp = bracket;
        circf = closed = nbra = ebra = 0;
        if(c == '^')
                circf++;
        else
                UNGETC(c);
        while(1) {
                if(ep >= endbuf)
                        ERROR(50);
                c = GETC();
                if(c != '*' && ((c != '\\') || (PEEKC() != '{')))
                        lastep = ep;
                if(c == eof) {
                        *ep++ = CCEOF;
                        if (bracketp != bracket)
                                ERROR(42);
                        RETURN(ep);
                }
                switch(c) {

                case '.':
                        *ep++ = CDOT;
                        continue;

                case '\n':
                        if(!sed) {
                                UNGETC(c);
                                *ep++ = CCEOF;
                                nodelim = 1;
                                if(bracketp != bracket)
                                        ERROR(42);
                                RETURN(ep);
                        }
                        else ERROR(36);
                case '*':
                        if(lastep == 0 || *lastep == CBRA || *lastep == CKET)
                                goto defchar;
                        *lastep |= STAR;
                        continue;

                case '$':
                        if(PEEKC() != eof && PEEKC() != '\n')
                                goto defchar;
                        *ep++ = CDOL;
                        continue;

                case '[':
                        if(&ep[17] >= endbuf)
                                ERROR(50);

                        *ep++ = CCL;
                        lc = 0;
                        for(i = 0; i < 16; i++)
                                ep[i] = 0;

                        neg = 0;
                        if((c = GETC()) == '^') {
                                neg = 1;
                                c = GETC();
                        }
                        iflag = 1;
                        do {
                                c &= 0377;
                                if(c == '\0' || c == '\n')
                                        ERROR(49);
                                if((c & 0200) && iflag) {
                                        iflag = 0;
                                        if(&ep[32] >= endbuf)
                                                ERROR(50);
                                        ep[-1] = CXCL;
                                        for(i = 16; i < 32; i++)
                                                ep[i] = 0;
                                }
                                if(c == '-' && lc != 0) {
                                        if((c = GETC()) == ']') {
                                                PLACE('-');
                                                break;
                                        }
                                        if((c & 0200) && iflag) {
                                                iflag = 0;
                                                if(&ep[32] >= endbuf)
                                                        ERROR(50);
                                                ep[-1] = CXCL;
                                                for(i = 16; i < 32; i++)
                                                        ep[i] = 0;
                                        }
                                        while(lc < c ) {
                                                PLACE(lc);
                                                lc++;
                                        }
                                }
                                lc = c;
                                PLACE(c);
                        } while((c = GETC()) != ']');

                        if(iflag)
                                iflag = 16;
                        else
                                iflag = 32;

                        if(neg) {
                                if(iflag == 32) {
                                        for(cclcnt = 0; cclcnt < iflag; cclcnt++)
                                                ep[cclcnt] ^= 0377;
                                        ep[0] &= 0376;
                                } else {
                                        ep[-1] = NCCL;
                                        /* make nulls match so test fails */
                                        ep[0] |= 01;
                                }
                        }

                        ep += iflag;

                        continue;

                case '\\':
                        switch(c = GETC()) {

                        case '(':
                                if(nbra >= NBRA)
                                        ERROR(43);
                                *bracketp++ = nbra;
                                *ep++ = CBRA;
                                *ep++ = nbra++;
                                continue;

                        case ')':
                                if(bracketp <= bracket || ++ebra != nbra)
                                        ERROR(42);
                                *ep++ = CKET;
                                *ep++ = *--bracketp;
                                closed++;
                                continue;

                        case '{':
                                if(lastep == (char *) 0)
                                        goto defchar;
                                *lastep |= RNGE;
                                cflg = 0;
                        nlim:
                                c = GETC();
                                i = 0;
                                do {
                                        if('0' <= c && c <= '9')
                                                i = 10 * i + c - '0';
                                        else
                                                ERROR(16);
                                } while(((c = GETC()) != '\\') && (c != ','));
                                if(i > 255)
                                        ERROR(11);
                                *ep++ = i;
                                if(c == ',') {
                                        if(cflg++)
                                                ERROR(44);
                                        if((c = GETC()) == '\\')
                                                *ep++ = 255;
                                        else {
                                                UNGETC(c);
                                                goto nlim;
                                                /* get 2'nd number */
                                        }
                                }
                                if(GETC() != '}')
                                        ERROR(45);
                                if(!cflg)       /* one number */
                                        *ep++ = i;
                                else if((ep[-1] & 0377) < (ep[-2] & 0377))
                                        ERROR(46);
                                continue;

                        case '\n':
                                ERROR(36);

                        case 'n':
                                c = '\n';
                                goto defchar;

                        default:
                                if(c >= '1' && c <= '9') {
                                        if((c -= '1') >= closed)
                                                ERROR(25);
                                        *ep++ = CBACK;
                                        *ep++ = c;
                                        continue;
                                }
                        }
        /* Drop through to default to use \ to turn off special chars */

                defchar:
                default:
                        lastep = ep;
                        *ep++ = CCHR;
                        *ep++ = c;
                }
        }
}

int step(p1, p2)
register char *p1, *p2;
{
        register c;


        if(circf) {
                loc1 = p1;
                return(advance(p1, p2));
        }
        /* fast check for first character */
        if(*p2 == CCHR) {
                c = p2[1];
                do {
                        if(*p1 != c)
                                continue;
                        if(advance(p1, p2)) {
                                loc1 = p1;
                                return(1);
                        }
                } while(*p1++);
                return(0);
        }
                /* regular algorithm */
        do {
                if(advance(p1, p2)) {
                        loc1 = p1;
                        return(1);
                }
        } while(*p1++);
        return(0);
}

static
getrnge(str)
register unsigned char *str;
{
        low = *str++ & 0377;
        size = (*str == 255)? 20000: (*str &0377) - low;
}

advance(lp, ep)
register char *lp, *ep;
{
        register char *curlp;
        int c;
        char *bbeg;
        register char neg;
        int ct;

        while(1) {
                neg = 0;
                switch(*ep++) {

                case CCHR:
                        if(*ep++ == *lp++)
                                continue;
                        return(0);

                case CDOT:
                        if(*lp++)
                                continue;
                        return(0);

                case CDOL:
                        if(*lp == 0)
                                continue;
                        return(0);

                case CCEOF:
                        loc2 = lp;
                        return(1);

                case CXCL:
                        c = (unsigned char)*lp++;
                        if(ISTHERE(c)) {
                                ep += 32;
                                continue;
                        }
                        return(0);

                case NCCL:
                        neg = 1;

                case CCL:
                        c = *lp++;
                        if(((c & 0200) == 0 && ISTHERE(c)) ^ neg) {
                                ep += 16;
                                continue;
                        }
                        return(0);

                case CBRA:
                        braslist[*ep++] = lp;
                        continue;

                case CKET:
                        braelist[*ep++] = lp;
                        continue;

                case CCHR | RNGE:
                        c = *ep++;
                        getrnge(ep);
                        while(low--)
                                if(*lp++ != c)
                                        return(0);
                        curlp = lp;
                        while(size--)
                                if(*lp++ != c)
                                        break;
                        if(size < 0)
                                lp++;
                        ep += 2;
                        goto star;

                case CDOT | RNGE:
                        getrnge(ep);
                        while(low--)
                                if(*lp++ == '\0')
                                        return(0);
                        curlp = lp;
                        while(size--)
                                if(*lp++ == '\0')
                                        break;
                        if(size < 0)
                                lp++;
                        ep += 2;
                        goto star;

                case CXCL | RNGE:
                        getrnge(ep + 32);
                        while(low--) {
                                c = (unsigned char)*lp++;
                                if(!ISTHERE(c))
                                        return(0);
                        }
                        curlp = lp;
                        while(size--) {
                                c = (unsigned char)*lp++;
                                if(!ISTHERE(c))
                                        break;
                        }
                        if(size < 0)
                                lp++;
                        ep += 34;               /* 32 + 2 */
                        goto star;

                case NCCL | RNGE:
                        neg = 1;

                case CCL | RNGE:
                        getrnge(ep + 16);
                        while(low--) {
                                c = *lp++;
                                if(((c & 0200) || !ISTHERE(c)) ^ neg)
                                        return(0);
                        }
                        curlp = lp;
                        while(size--) {
                                c = *lp++;
                                if(((c & 0200) || !ISTHERE(c)) ^ neg)
                                        break;
                        }
                        if(size < 0)
                                lp++;
                        ep += 18;               /* 16 + 2 */
                        goto star;

                case CBACK:
                        bbeg = braslist[*ep];
                        ct = braelist[*ep++] - bbeg;

                        if(ecmp(bbeg, lp, ct)) {
                                lp += ct;
                                continue;
                        }
                        return(0);

                case CBACK | STAR:
                        bbeg = braslist[*ep];
                        ct = braelist[*ep++] - bbeg;
                        curlp = lp;
                        while(ecmp(bbeg, lp, ct))
                                lp += ct;

                        while(lp >= curlp) {
                                if(advance(lp, ep))     return(1);
                                lp -= ct;
                        }
                        return(0);


                case CDOT | STAR:
                        curlp = lp;
                        while(*lp++);
                        goto star;

                case CCHR | STAR:
                        curlp = lp;
                        while(*lp++ == *ep);
                        ep++;
                        goto star;

                case CXCL | STAR:
                        curlp = lp;
                        do {
                                c = (unsigned char)*lp++;
                        } while(ISTHERE(c));
                        ep += 32;
                        goto star;

                case NCCL | STAR:
                        neg = 1;

                case CCL | STAR:
                        curlp = lp;
                        do {
                                c = *lp++;
                        } while(((c & 0200) == 0 && ISTHERE(c)) ^ neg);
                        ep += 16;
                        goto star;

                star:
                        do {
                                if(--lp == locs)
                                        break;
                                if(advance(lp, ep))
                                        return(1);
                        } while(lp > curlp);
                        return(0);

                }
        }
}
reloc.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)reloc.h      1.1 86/05/15";
*/
/*      @(#)reloc.h     2.1     */
struct reloc {
        long    r_vaddr;        /* (virtual) address of reference */
        long    r_symndx;       /* index into symbol table */
        unsigned short  r_type;         /* relocation type */
        };


/*
 *   relocation types for all products and generics
 */

/*
 * All generics
 *      reloc. already performed to symbol in the same section
 */
#define  R_ABS          0

/*
 * X86 generic
 *      8-bit offset reference in 8-bits
 *      8-bit offset reference in 16-bits
 *      12-bit segment reference
 *      auxiliary relocation entry
 */
#define R_OFF8          07
#define R_OFF16         010
#define R_SEG12         011
#define R_AUX           013

/*
 * B16 and X86 generics
 *      16-bit direct reference
 *      16-bit "relative" reference
 *      16-bit "indirect" (TV) reference
 */
#define  R_DIR16        01
#define  R_REL16        02
#define  R_IND16        03

/*
 * 3B generic
 *      24-bit direct reference
 *      24-bit "relative" reference
 *      16-bit optimized "indirect" TV reference
 *      24-bit "indirect" TV reference
 *      32-bit "indirect" TV reference
 */
#define  R_DIR24        04
#define  R_REL24        05
#define  R_OPT16        014
#define  R_IND24        015
#define  R_IND32        016

/*
 * 3B and M32 generics
 *      32-bit direct reference
 */
#define  R_DIR32        06

/*
 * M32 generic
 *      32-bit direct reference with bytes swapped
 */
#define  R_DIR32S       012

/*
 * DEC Processors  VAX 11/780 and VAX 11/750
 * Also, M68000
 *
 */

#define R_RELBYTE       017
#define R_RELWORD       020
#define R_RELLONG       021
#define R_PCRBYTE       022
#define R_PCRWORD       023
#define R_PCRLONG       024


#define RELOC   struct reloc
#define RELSZ   10      /* sizeof(RELOC) */

        /* Definition of a "TV" relocation type */

#if N3B
#define ISTVRELOC(x)    ((x==R_OPT16)||(x==R_IND24)||(x==R_IND32))
#endif
#if B16 || X86
#define ISTVRELOC(x)    (x==R_IND16)
#endif
#if M32
#define ISTVRELOC(x)    (x!=x)  /* never the case */
#endif
rje.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)rje.h        1.1 86/05/15";
*/
/*      @(#)rje.h       1.2     */
#define MAXDEVS 7               /* Maximum number of devices (readers, etc.) */
#define LINEFIL "/usr/rje/lines"
#ifdef u3b
#define RJECU   "/dev/acu2"     /* Dial-up RJE device */
#else
#define RJECU   "/dev/dn2"      /* Dial-up RJE device */
#endif
#define RJELOGIN "rje"          /* rje login name */
#define RJEUID  68            /* User-Id for "rje" */
#define SHQUID  69            /* User-Id for "shqer" */
#define RJEGID   8              /* Group-Id for "rje" and "shqer" */
#define QUEDIR  "/usr/rje/sque" /* shqer directory */
#define QUELOG  "log"           /* shqer log file name */
#define QUELEN  50              /* Length of a shqer log entry */
#define QDELAY  180             /* Delay time for shqer */
#define QNICE   0
#define BOOTDLY 60              /* Reboot delay time (seconds) */
#define RESPMAX 70000           /* Max resp file size */

#define DEVFD   0       /* KMC device file descriptor */
#define XMTRD   1       /* xmit read file descriptor */
#define ERRFD   2       /* errors file descriptor */
#define XMTWR   3       /* xmit write file descriptor */
#define DSPRD   4       /* disp read file descriptor */
#define DSPWR   5       /* disp write file descriptor */
#define JBLOG   6       /* joblog file descriptor */

#define NAMESZ  8

struct joblog {
        char j_file[NAMESZ];    /* Name of file to be sent */
        unsigned j_uid;         /* User ID of owner */
        int j_lvl;              /* Message level */
        long j_cnt;             /* Number of "cards" */
};

        /* joblog header info */

struct loghdr {
        int h_pgrp;             /* Process group Id */
};
#define LBUFMAX 100
#define MAXLNS  6
struct lines {
        char *l_host;           /* RJE host machine */
        char *l_sys;            /* This system */
        char *l_dir;            /* home directory */
        char *l_prefix;         /* rje prefix */
        char *l_dev;            /* device for transfer */
        char *l_peri;           /* Peripherals field */
        char *l_parm;           /* Parameters field */
        char l_buf[LBUFMAX];    /* buffer for fields */
};

struct dsplog {
        int d_type;             /* Type of record */
        union {
                struct {        /* record from xmit */
                        char d_file[NAMESZ];    /* file sent */
                        long d_cnt;             /* no. of cards sent */
                        unsigned d_uid;         /* who sent the file */
                        int d_lvl;              /* message level */
                        int d_rdr;              /* reader sent from (0-6) */
                } x;
                struct {        /* record from recv */
                        char d_file[NAMESZ];    /* file received */
                        long d_cnt;             /* no. of records */
                        int d_trunc;            /* file truncation flag */
                } r;
        } d_un;
};

struct sque {
        char sq_exfil[140];     /* Executable file */
        char sq_infil[48];      /* Input file */
        char sq_jobnm[9];       /* Remote job name */
        char sq_pgrmr[25];      /* Programmer name */
        char sq_jobno[9];       /* Remote job number */
        char sq_login[9];       /* Login name from usr= */
        char sq_homed[48];      /* Login directory */
        long sq_min;            /* Minimum file system space */
};
scnhdr.h
/*      Copyright (c) 1984 AT&T */
/*        All Rights Reserved   */

/*      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T     */
/*      The copyright notice above does not evidence any        */
/*      actual or intended publication of such source code.     */

/*---------------------------------------------------------------------------
   COPYRIGHT (c) 1990   TEXAS INSTRUMENTS INCORPORATED   ALL RIGHTS RESERVED
-----------------------------------------------------------------------------*/
#ident  "@(#)scnhdr.h   1.2 90/12/18"

struct scnhdr {
        char            s_name[8];      /* section name */
        long            s_paddr;        /* physical address, aliased s_nlib */
        long            s_vaddr;        /* virtual address */
        long            s_size;         /* section size */
        long            s_scnptr;       /* file ptr to raw data for section */
        long            s_relptr;       /* file ptr to relocation */
        long            s_lnnoptr;      /* file ptr to line numbers */
        unsigned short  s_nreloc;       /* number of relocation entries */
        unsigned short  s_nlnno;        /* number of line number entries */
        long            s_flags;        /* flags */
        };

/* the number of shared libraries in a .lib section in an absolute output file
 * is put in the s_paddr field of the .lib section header, the following define
 * allows it to be referenced as s_nlib
 */

#define s_nlib  s_paddr
#define SCNHDR  struct scnhdr
#define SCNHSZ  sizeof(SCNHDR)

/*
 * Define constants for names of "special" sections
 */

#define _TEXT    ".text"
#define _DATA    ".data"
#define _BSS     ".bss"
#define _TV      ".tv"
#define _INIT    ".init"
#define _FINI    ".fini"

/*
 * The low 2 bytes of s_flags is used as a section "type"
 */

#define STYP_REG        0x00            /* "regular" section:
                                                allocated, relocated, loaded */
#define STYP_DSECT      0x01            /* "dummy" section:
                                                not allocated, relocated,
                                                not loaded */
#define STYP_NOLOAD     0x02            /* "noload" section:
                                                allocated, relocated,
                                                 not loaded */
#define STYP_GROUP      0x04            /* "grouped" section:
                                                formed of input sections */
#define STYP_PAD        0x08            /* "padding" section:
                                                not allocated, not relocated,
                                                 loaded */
#define STYP_COPY       0x10            /* "copy" section:
                                                for decision function used
                                                by field update;  not
                                                allocated, not relocated,
                                                loaded;  reloc & lineno
                                                entries processed normally */
#define STYP_INFO       0x200           /* comment section : not allocated
                                                not relocated, not loaded */
#define STYP_LIB        0x800           /* for .lib section : same as INFO */
#define STYP_OVER       0x400           /* overlay section : relocated
                                                not allocated or loaded */
#define STYP_TEXT       0x20            /* section contains text only */
#define STYP_DATA       0x40            /* section contains data only */
#define STYP_BSS        0x80            /* section contains bss only */

/*
 *  In a minimal file or an update file, a new function
 *  (as compared with a replaced function) is indicated by S_NEWFCN
 */

#define S_NEWFCN  0x100

/*
 * In 3b Update Files (output of ogen), sections which appear in SHARED
 * segments of the Pfile will have the S_SHRSEG flag set by ogen, to inform
 * dufr that updating 1 copy of the proc. will update all process invocations.
 */

#define S_SHRSEG        0x20
search.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)search.h     1.1 86/05/15";
*/
/*      @(#)search.h    1.1     */
/* HSEARCH(3C) */
typedef struct entry { char *key, *data; } ENTRY;
typedef enum { FIND, ENTER } ACTION;

/* TSEARCH(3C) */
typedef enum { preorder, postorder, endorder, leaf } VISIT;
setjmp.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)setjmp.h     1.1 86/05/15";
*/
/*      @(#)setjmp.h    1.3     */
#ifndef _JBLEN

#if vax || u3b5
#define _JBLEN  10
#endif

#if pdp11
#define _JBLEN  3
#endif

#if u370
#define _JBLEN  4
#endif

#if u3b
#define _JBLEN  11
#endif

#if m68k
#define _JBLEN  13
#endif

typedef int jmp_buf[_JBLEN];

extern int setjmp();
extern void longjmp();

#endif
sgtty.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)sgtty.h      1.1 86/05/15";
*/
/*      @(#)sgtty.h     1.1     */
/*      3.0 SID #       1.1     */
/*
 * Structure for stty and gtty system calls.
 */

struct sgttyb {
        char    sg_ispeed;              /* input speed */
        char    sg_ospeed;              /* output speed */
        char    sg_erase;               /* erase character */
        char    sg_kill;                /* kill character */
        int     sg_flags;               /* mode flags */
};

/*
 * Modes
 */
#define HUPCL   01
#define XTABS   02
#define LCASE   04
#define ECHO    010
#define CRMOD   020
#define RAW     040
#define ODDP    0100
#define EVENP   0200
#define ANYP    0300
#define NLDELAY 001400
#define TBDELAY 002000
#define CRDELAY 030000
#define VTDELAY 040000
#define BSDELAY 0100000
#define ALLDELAY 0177400

/*
 * Delay algorithms
 */
#define CR0     0
#define CR1     010000
#define CR2     020000
#define CR3     030000
#define NL0     0
#define NL1     000400
#define NL2     001000
#define NL3     001400
#define TAB0    0
#define TAB1    002000
#define NOAL    004000
#define FF0     0
#define FF1     040000
#define BS0     0
#define BS1     0100000

/*
 * Speeds
 */
#define B0      0
#define B50     1
#define B75     2
#define B110    3
#define B134    4
#define B150    5
#define B200    6
#define B300    7
#define B600    8
#define B1200   9
#define B1800   10
#define B2400   11
#define B4800   12
#define B9600   13
#define EXTA    14
#define EXTB    15

/*
 *      ioctl arguments
 */
#define FIOCLEX         (('f'<<8)|1)
#define FIONCLEX        (('f'<<8)|2)
#define TIOCHPCL        (('t'<<8)|2)
#define TIOCGETP        (('t'<<8)|8)
#define TIOCSETP        (('t'<<8)|9)
#define TIOCEXCL        (('t'<<8)|13)
#define TIOCNXCL        (('t'<<8)|14)
shadow.h
/*
        (C) COPYRIGHT, TEXAS INSTRUMENTS INCORPORATED, 1989.  ALL
        RIGHTS RESERVED.  PROPERTY OF TEXAS INSTRUMENTS INCORPORATED.
        RESTRICTED RIGHTS - USE, DUPLICATION, OR DISCLOSURE IS SUBJECT
        TO RESTRICTIONS SET FORTH IN TI'S PROGRAM LICENSE AGREEMENT AND
        ASSOCIATED DOCUMENTATION.
*/

#ifdef  SCCSID
static char s5dir_h[] = "@(#)shadow.h   1.3 (TI) 89/12/07";
#endif  SCCSID

#define PASSWD          "/etc/passwd"
#define LPASSWD         "/etc/passwd.local"
#define SHADOW          "/etc/shadow"
#define OPASSWD         "/etc/opasswd"
#define OSHADOW         "/etc/oshadow"
#define PASSTEMP        "/etc/ptmp"
#define SHADTEMP        "/etc/stmp"

#define DAY             (24L * 60 * 60) /* 1 day in seconds */
#define DAY_NOW         (long)time((long *)0) / DAY

/* The spwd structure is used in the retreval of information from
   /etc/shadow.  It is used by routines in the libsec library */

struct spwd {
        char *sp_namp ; /* user name */
        char *sp_pwdp ; /* user password */
        long sp_lstchg ; /* password lastchanged date */
        long sp_min ; /* minimum number of days between password changes */
        long sp_max ; /* number of days password is valid */
} ;

/* Declare all shadow password functions */

void            setspent(), endspent() ;
struct spwd     *getspent(), *fgetspent(), *getspnam() ;
int             putspent(), lckpwdf(), ulckpwdf() ;
signal.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)signal.h     1.5 88/03/17";
*/
/*      @(#)signal.h    1.1     */
/*      3.0 SID #       1.3     */
#include<sys/signal.h>

extern  void(*signal())();
extern  void(*sigset())();
stand.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)stand.h      1.1 86/05/15";
*/
/*      @(#)stand.h     1.4     */

/*
 * Header file for standalone package
 */

#ifdef vax || m68k
#define FsTYPE  2
#else
#define FsTYPE  1
#endif
#include "errno.h"
#include "sys/param.h"
#include "sys/types.h"
#include "sys/inode.h"

/*
 * I/O block flags
 */

#define F_READ  01
#define F_WRITE 02
#define F_ALLOC 04
#define F_FILE  010

/*
 * Request codes -- must be
 * the same as an F_XXX above
 */

#define READ    1
#define WRITE   2

/*
 * Buffer sizes
 */

#if FsTYPE == 2
#define BLKSIZ  1024
#else
#define BLKSIZ  512
#endif
#define NAMSIZ  60

/*
 * devsw table --
 * initialized in conf.c
 */

struct devsw {
        int     (*dv_strategy)();
        int     (*dv_open)();
        int     (*dv_close)();
};
extern struct devsw _devsw[];

/*
 * dtab table -- entries
 * are created by MKNOD
 */

#define NDEV    16

struct dtab {
        char            *dt_name;
        struct devsw    *dt_devp;
        int             dt_unit;
        daddr_t         dt_boff;
};
extern struct dtab _dtab[];

/*
 * mtab table -- entries
 * are created by mount
 */

#define NMOUNT  8

struct mtab {
        char            *mt_name;
        struct dtab     *mt_dp;
};
extern struct mtab _mtab[];

/*
 * I/O block: includes an inode,
 * cells for the use of seek, etc,
 * and a buffer.
 */

#define NFILES  6

struct iob {
        char            i_flgs;
        struct inode    i_ino;
        time_t          i_atime;
        time_t          i_mtime;
        time_t          i_ctime;
        struct dtab     *i_dp;
        off_t           i_offset;
        daddr_t         i_bn;           /* disk block number (physical) */
        char            *i_ma;
        int             i_cc;           /* character count */
        char            i_buf[BLKSIZ];
};
extern struct iob _iobuf[];

#ifdef pdp11
/*
 * Set to which 32Kw segment the code is physically running in.
 * Must be set by the user's main (or thereabouts).
 */

int     segflag;
#endif

/*
 * Set to the error type of the routine that
 * last returned an error -- may be read by perror.
 */

extern int errno;
#define RAW     040
#define LCASE   04
#define XTABS   02
#define ECHO    010
#define CRMOD   020
#define B300    7
struct sgttyb {
        char    sg_ispeed;              /* input speed */
        char    sg_ospeed;              /* output speed */
        char    sg_erase;               /* erase character */
        char    sg_kill;                /* kill character */
        int     sg_flags;               /* mode flags */
};
stdio.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)stdio.h      1.4 89/05/05";
*/
/*      @(#)stdio.h     2.7     */
#ifndef _NFILE
#define _NFILE  100

#if u370
#define BUFSIZ  4096
#endif
#if vax || u3b || u3b5 || m68k
#define BUFSIZ  1024
#endif
#if pdp11
#define BUFSIZ  512
#endif

/* buffer size for multi-character output to unbuffered files */
#define _SBFSIZ 8

typedef struct {
#if vax || u3b || u3b5 || m68k
        int     _cnt;
        unsigned char   *_ptr;
#else
        unsigned char   *_ptr;
        int     _cnt;
#endif
        unsigned char   *_base;
        char    _flag;
        char    _file;
} FILE;

/*
 * _IOLBF means that a file's output will be buffered line by line
 * In addition to being flags, _IONBF, _IOLBF and _IOFBF are possible
 * values for "type" in setvbuf.
 */
#define _IOFBF          0000
#define _IOREAD         0001
#define _IOWRT          0002
#define _IONBF          0004
#define _IOMYBUF        0010
#define _IOEOF          0020
#define _IOERR          0040
#define _IOLBF          0100
#define _IORW           0200

#ifndef NULL
#define NULL            0
#endif
#ifndef EOF
#define EOF             (-1)
#endif

#define stdin           (&_iob[0])
#define stdout          (&_iob[1])
#define stderr          (&_iob[2])

#define _bufend(p)      _bufendtab[(p)->_file]
#define _bufsiz(p)      (_bufend(p) - (p)->_base)

#ifndef lint
#define getc(p)         (--(p)->_cnt < 0 ? _filbuf(p) : (int) *(p)->_ptr++)
#define putc(x, p)      (--(p)->_cnt < 0 ? \
                        _flsbuf((unsigned char) (x), (p)) : \
                        (int) (*(p)->_ptr++ = (unsigned char) (x)))
#define getchar()       getc(stdin)
#define putchar(x)      putc((x), stdout)
#define clearerr(p)     ((void) ((p)->_flag &= ~(_IOERR | _IOEOF)))
#define feof(p)         ((p)->_flag & _IOEOF)
#define ferror(p)       ((p)->_flag & _IOERR)
#define fileno(p)       (p)->_file
#endif

extern FILE     _iob[_NFILE];
extern FILE     *fopen(), *fdopen(), *freopen(), *popen(), *tmpfile();
extern long     ftell();
extern void     rewind(), setbuf();
extern char     *ctermid(), *cuserid(), *fgets(), *gets(), *tempnam(), *tmpnam();
extern unsigned char *_bufendtab[];

#define L_ctermid       9
#define L_cuserid       9
#define P_tmpdir        "/usr/tmp/"
#define L_tmpnam        (sizeof(P_tmpdir) + 15)
#endif
stermio.h
/*
        (C) COPYRIGHT, TEXAS INSTRUMENTS INCORPORATED, 1984.  ALL
        RIGHTS RESERVED.  PROPERTY OF TEXAS INSTRUMENTS INCORPORATED.
        RESTRICTED RIGHTS - USE, DUPLICATION, OR DISCLOSURE IS SUBJECT
        TO RESTRICTIONS SET FORTH IN TI'S PROGRAM LICENSE AGREEMENT AND
        ASSOCIATED DOCUMENTATION.
*/
/*
static char *sccs_id = @(#)stermio.h    1.1 86/05/15";
*/

/* @(#)stermio.h        1.1     UNIX System V/68 */
/*
 * ioctl commands for control channels
 */
#define STSTART         1       /* start protocol */
#define STHALT          2       /* cease protocol */
#define STPRINT         3       /* assign device to printer */

/*
 * ioctl commands for terminal and printer channels
 */
#define STGET   (('X'<<8)|0)    /* get line options */
#define STSET   (('X'<<8)|1)    /* set line options */
#define STTHROW (('X'<<8)|2)    /* throw away queued input */
#define STWLINE (('X'<<8)|3)    /* get synchronous line # */

struct stio {
        unsigned short  ttyid;
        char            row;
        char            col;
        char            orow;
        char            ocol;
        char            tab;
        char            aid;
        char            ss1;
        char            ss2;
        unsigned short  imode;
        unsigned short  lmode;
        unsigned short  omode;
};

/*
**      Mode Definitions.
*/
#define STFLUSH 00400   /* FLUSH mode; lmode */
#define STWRAP  01000   /* WRAP mode; lmode */
#define STAPPL  02000   /* APPLICATION mode; lmode */
storclass.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)storclass.h  1.1 86/05/15";
*/
/*      @(#)storclass.h 2.2 12/15/82    */

/*
 *   STORAGE CLASSES
 */

#define  C_EFCN          -1    /* physical end of function */
#define  C_NULL          0
#define  C_AUTO          1     /* automatic variable */
#define  C_EXT           2     /* external symbol */
#define  C_STAT          3     /* static */
#define  C_REG           4     /* register variable */
#define  C_EXTDEF        5     /* external definition */
#define  C_LABEL         6     /* label */
#define  C_ULABEL        7     /* undefined label */
#define  C_MOS           8     /* member of structure */
#define  C_ARG           9     /* function argument */
#define  C_STRTAG        10    /* structure tag */
#define  C_MOU           11    /* member of union */
#define  C_UNTAG         12    /* union tag */
#define  C_TPDEF         13    /* type definition */
#define  C_USTATIC       14    /* undefined static */
#define  C_ENTAG         15    /* enumeration tag */
#define  C_MOE           16    /* member of enumeration */
#define  C_REGPARM       17    /* register parameter */
#define  C_FIELD         18    /* bit field */
#define  C_BLOCK         100   /* ".bb" or ".eb" */
#define  C_FCN           101   /* ".bf" or ".ef" */
#define  C_EOS           102   /* end of structure */
#define  C_FILE          103   /* file name */

        /*
         * The following storage class is a "dummy" used only by STS
         * for line number entries reformatted as symbol table entries
         */

#define  C_LINE          104
#define  C_ALIAS         105   /* duplicate tag */
#define  C_HIDDEN        106   /* special storage class for external */
                               /* symbols in dmert public libraries  */
string.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)string.h     1.2 91/08/12";
*/
/*      @(#)string.h    1.2     */
#ifndef _STRING_FUNC
#define _STRING_FUNC
extern char
        *strcpy(),
        *strncpy(),
        *strcat(),
        *strncat(),
        *strchr(),
        *strrchr(),
        *strpbrk(),
        *strtok();
extern int
        strcmp(),
        strncmp(),
        strlen(),
        strspn(),
        strcspn();
#endif /* _STRING_FUNC */
stropts.h
/*      Copyright (c) 1984 AT&T */
/*        All Rights Reserved   */

/*      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T     */
/*      The copyright notice above does not evidence any        */
/*      actual or intended publication of such source code.     */

/*
static char *sccs_id = "@(#)stropts.h   1.2 90/02/22";
*/
/*
 * Streams user options definitions.
 */

#include <sys/stropts.h>
symbol.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)symbol.h     1.1 86/05/15";
*/
/*      @(#)symbol.h    1.1     */
/*      3.0 SID #       1.1     */
/*
 * Structure of a symbol table entry
 */

struct  symbol {
        char    sy_name[8];
        char    sy_type;
        int     sy_value;
};
syms.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)syms.h       1.1 86/05/15";
*/
/*      @(#)syms.h      2.4 2/28/83     */

/*              Storage Classes are defined in storclass.h  */
#include "storclass.h"

/*              Number of characters in a symbol name */
#define  SYMNMLEN       8
/*              Number of characters in a file name */
#define  FILNMLEN       14
/*              Number of array dimensions in auxiliary entry */
#define  DIMNUM         4


struct syment
{
        union
        {
                char            _n_name[SYMNMLEN];      /* old COFF version */
                struct
                {
                        long    _n_zeroes;      /* new == 0 */
                        long    _n_offset;      /* offset into string table */
                } _n_n;
                char            *_n_nptr[2];    /* allows for overlaying */
        } _n;
#ifndef pdp11
        unsigned
#endif
        long                    n_value;        /* value of symbol */
        short                   n_scnum;        /* section number */
        unsigned short          n_type;         /* type and derived type */
        char                    n_sclass;       /* storage class */
        char                    n_numaux;       /* number of aux. entries */
};

#define n_name          _n._n_name
#define n_nptr          _n._n_nptr[1]
#define n_zeroes        _n._n_n._n_zeroes
#define n_offset        _n._n_n._n_offset

/*
   Relocatable symbols have a section number of the
   section in which they are defined.  Otherwise, section
   numbers have the following meanings:
*/
        /* undefined symbol */
#define  N_UNDEF        0
        /* value of symbol is absolute */
#define  N_ABS          -1
        /* special debugging symbol -- value of symbol is meaningless */
#define  N_DEBUG        -2
        /* indicates symbol needs transfer vector (preload) */
#define  N_TV           (unsigned short)-3

        /* indicates symbol needs transfer vector (postload) */

#define  P_TV           (unsigned short)-4

/*
   The fundamental type of a symbol packed into the low
   4 bits of the word.
*/

#define  _EF    ".ef"

#define  T_NULL     0
#define  T_ARG      1          /* function argument (only used by compiler) */
#define  T_CHAR     2          /* character */
#define  T_SHORT    3          /* short integer */
#define  T_INT      4          /* integer */
#define  T_LONG     5          /* long integer */
#define  T_FLOAT    6          /* floating point */
#define  T_DOUBLE   7          /* double word */
#define  T_STRUCT   8          /* structure  */
#define  T_UNION    9          /* union  */
#define  T_ENUM     10         /* enumeration  */
#define  T_MOE      11         /* member of enumeration */
#define  T_UCHAR    12         /* unsigned character */
#define  T_USHORT   13         /* unsigned short */
#define  T_UINT     14         /* unsigned integer */
#define  T_ULONG    15         /* unsigned long */

/*
 * derived types are:
 */

#define  DT_NON      0          /* no derived type */
#define  DT_PTR      1          /* pointer */
#define  DT_FCN      2          /* function */
#define  DT_ARY      3          /* array */

/*
 *   type packing constants
 */

#define  N_BTMASK     017
#define  N_TMASK      060
#define  N_TMASK1     0300
#define  N_TMASK2     0360
#define  N_BTSHFT     4
#define  N_TSHIFT     2

/*
 *   MACROS
 */

        /*   Basic Type of  x   */

#define  BTYPE(x)  ((x) & N_BTMASK)

        /*   Is  x  a  pointer ?   */

#define  ISPTR(x)  (((x) & N_TMASK) == (DT_PTR << N_BTSHFT))

        /*   Is  x  a  function ?  */

#define  ISFCN(x)  (((x) & N_TMASK) == (DT_FCN << N_BTSHFT))

        /*   Is  x  an  array ?   */

#define  ISARY(x)  (((x) & N_TMASK) == (DT_ARY << N_BTSHFT))

        /* Is x a structure, union, or enumeration TAG? */

#define ISTAG(x)  ((x)==C_STRTAG || (x)==C_UNTAG || (x)==C_ENTAG)

#define  INCREF(x) ((((x)&~N_BTMASK)<<N_TSHIFT)|(DT_PTR<<N_BTSHFT)|(x&N_BTMASK))

#define  DECREF(x) ((((x)>>N_TSHIFT)&~N_BTMASK)|((x)&N_BTMASK))

/*
 *      AUXILIARY ENTRY FORMAT
 */

union auxent
{
        struct
        {
                long            x_tagndx;       /* str, un, or enum tag indx */
                union
                {
                        struct
                        {
                                unsigned short  x_lnno; /* declaration line number */
                                unsigned short  x_size; /* str, union, array size */
                        } x_lnsz;
                        long    x_fsize;        /* size of function */
                } x_misc;
                union
                {
                        struct                  /* if ISFCN, tag, or .bb */
                        {
                                long    x_lnnoptr;      /* ptr to fcn line # */
                                long    x_endndx;       /* entry ndx past block end */
                        }       x_fcn;
                        struct                  /* if ISARY, up to 4 dimen. */
                        {
                                unsigned short  x_dimen[DIMNUM];
                        }       x_ary;
                }               x_fcnary;
                unsigned short  x_tvndx;                /* tv index */
        }       x_sym;
        struct
        {
                char    x_fname[FILNMLEN];
        }       x_file;
        struct
        {
                long    x_scnlen;          /* section length */
                unsigned short  x_nreloc;  /* number of relocation entries */
                unsigned short  x_nlinno;  /* number of line numbers */
        }       x_scn;

        struct
        {
                long            x_tvfill;       /* tv fill value */
                unsigned short  x_tvlen;        /* length of .tv */
                unsigned short  x_tvran[2];     /* tv range */
        }       x_tv;   /* info about .tv section (in auxent of symbol .tv)) */
};

#define SYMENT  struct syment
#define SYMESZ  18      /* sizeof(SYMENT) */

#define AUXENT  union auxent
#define AUXESZ  18      /* sizeof(AUXENT) */

/*      Defines for "special" symbols   */

#if vax
#define _ETEXT  "_etext"
#define _EDATA  "_edata"
#define _END    "_end"
#else
#define _ETEXT  "etext"
#define _EDATA  "edata"
#define _END    "end"
#endif

#define _START  "_start"
term.h
/*      Copyright (c) 1984 AT&T */
/*        All Rights Reserved   */

/*      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T     */
/*      The copyright notice above does not evidence any        */
/*      actual or intended publication of such source code.     */


/*
 * term.h - this file is automatically made from caps and maketerm.ed.
 * Don't make changes directly to term.h.
 *
 * Guard against multiple includes.
 */

#ifndef auto_left_margin

#define auto_left_margin                CUR _b1
#define auto_right_margin               CUR _b2
#define no_esc_ctlc                     CUR _b3
#define ceol_standout_glitch            CUR _b4
#define eat_newline_glitch              CUR _b5
#define erase_overstrike                CUR _b6
#define generic_type                    CUR _b7
#define hard_copy                       CUR _b8
#define has_meta_key                    CUR _b9
#define has_status_line                 CUR _b10
#define insert_null_glitch              CUR _b11
#define memory_above                    CUR _b12
#define memory_below                    CUR _b13
#define move_insert_mode                CUR _b14
#define move_standout_mode              CUR _b15
#define over_strike                     CUR _b16
#define status_line_esc_ok              CUR _b17
#define dest_tabs_magic_smso            CUR _b18
#define tilde_glitch                    CUR _b19
#define transparent_underline           CUR _b20
#define xon_xoff                        CUR _b21
#define needs_xon_xoff                  CURB _needs_xon_xoff
#define prtr_silent                     CURB _prtr_silent
#define hard_cursor                     CURB _hard_cursor
#define non_rev_rmcup                   CURB _non_rev_rmcup
#define no_pad_char                     CURB _no_pad_char
#define non_dest_scroll_region          CURB _non_dest_scroll_region
#define can_change                      CURB _can_change
#define back_color_erase                CURB _back_color_erase
#define hue_lightness_saturation                CURB _hue_lightness_saturation
#define ti931_glitch                    CURB _ti931_glitch
#define col_addr_glitch                 CURB _col_addr_glitch
#define cr_cancels_micro_mode           CURB _cr_cancels_micro_mode
#define has_print_wheel                 CURB _has_print_wheel
#define row_addr_glitch                 CURB _row_addr_glitch
#define semi_auto_right_margin          CURB _semi_auto_right_margin
#define cpi_changes_res                 CURB _cpi_changes_res
#define lpi_changes_res                 CURB _lpi_changes_res
#define columns                         CUR _c1
#define init_tabs                       CUR _c2
#define lines                           CUR _c3
#define lines_of_memory                 CUR _c4
#define magic_cookie_glitch             CUR _c5
#define padding_baud_rate               CUR _c6
#define virtual_terminal                CUR _c7
#define width_status_line               CUR _c8
#define num_labels                      CURN _num_labels
#define label_height                    CURN _labl_height
#define label_width                     CURN _labl_width
#define max_attributes                  CURN _max_attributes
#define maximum_windows                 CURN _maximum_windows
#define max_colors                      CURN _max_colors
#define max_pairs                       CURN _max_pairs
#define no_color_video                  CURN _no_color_video
#define buffer_capacity                 CURN _buffer_capacity
#define dot_vert_spacing                CURN _dot_vert_spacing
#define dot_horz_spacing                CURN _dot_horz_spacing
#define max_micro_address               CURN _max_micro_address
#define max_micro_jump                  CURN _max_micro_jump
#define micro_char_size                 CURN _micro_char_size
#define micro_line_size                 CURN _micro_line_size
#define number_of_pins                  CURN _number_of_pins
#define output_res_char                 CURN _output_res_char
#define output_res_line                 CURN _output_res_line
#define output_res_horz_inch            CURN _output_res_horz_inch
#define output_res_vert_inch            CURN _output_res_vert_inch
#define print_rate                      CURN _print_rate
#define wide_char_size                  CURN _wide_char_size
#define back_tab                        CUR _Vr2_Astrs._s1
#define bell                            CUR _Vr2_Astrs._s2
#define carriage_return                 CUR _Vr2_Astrs._s3
#define change_scroll_region            CUR _Vr2_Astrs._s4
#define clear_all_tabs                  CUR _Vr2_Astrs._s5
#define clear_screen                    CUR _Vr2_Astrs._s6
#define clr_eol                         CUR _Vr2_Astrs._s7
#define clr_eos                         CUR _Vr2_Astrs._s8
#define column_address                  CUR _Vr2_Astrs._s9
#define command_character               CUR _Vr2_Astrs._s10
#define cursor_address                  CUR _Vr2_Astrs._s11
#define cursor_down                     CUR _Vr2_Astrs._s12
#define cursor_home                     CUR _Vr2_Astrs._s13
#define cursor_invisible                CUR _Vr2_Astrs._s14
#define cursor_left                     CUR _Vr2_Astrs._s15
#define cursor_mem_address              CUR _Vr2_Astrs._s16
#define cursor_normal                   CUR _Vr2_Astrs._s17
#define cursor_right                    CUR _Vr2_Astrs._s18
#define cursor_to_ll                    CUR _Vr2_Astrs._s19
#define cursor_up                       CUR _Vr2_Astrs._s20
#define cursor_visible                  CUR _Vr2_Astrs._s21
#define delete_character                CUR _Vr2_Astrs._s22
#define delete_line                     CUR _Vr2_Astrs._s23
#define dis_status_line                 CUR _Vr2_Astrs._s24
#define down_half_line                  CUR _Vr2_Astrs._s25
#define enter_alt_charset_mode          CUR _Vr2_Astrs._s26
#define enter_blink_mode                CUR _Vr2_Astrs._s27
#define enter_bold_mode                 CUR _Vr2_Astrs._s28
#define enter_ca_mode                   CUR _Vr2_Astrs._s29
#define enter_delete_mode               CUR _Vr2_Astrs._s30
#define enter_dim_mode                  CUR _Vr2_Astrs._s31
#define enter_insert_mode               CUR _Vr2_Astrs._s32
#define enter_secure_mode               CUR _Vr2_Astrs._s33
#define enter_protected_mode            CUR _Vr2_Astrs._s34
#define enter_reverse_mode              CUR _Vr2_Astrs._s35
#define enter_standout_mode             CUR _Vr2_Astrs._s36
#define enter_underline_mode            CUR _Vr2_Astrs._s37
#define erase_chars                     CUR _Vr2_Astrs._s38
#define exit_alt_charset_mode           CUR _Vr2_Astrs._s39
#define exit_attribute_mode             CUR _Vr2_Astrs._s40
#define exit_ca_mode                    CUR _Vr2_Astrs._s41
#define exit_delete_mode                CUR _Vr2_Astrs._s42
#define exit_insert_mode                CUR _Vr2_Astrs._s43
#define exit_standout_mode              CUR _Vr2_Astrs._s44
#define exit_underline_mode             CUR _Vr2_Astrs._s45
#define flash_screen                    CUR _Vr2_Astrs._s46
#define form_feed                       CUR _Vr2_Astrs._s47
#define from_status_line                CUR _Vr2_Astrs._s48
#define init_1string                    CUR _Vr2_Astrs._s49
#define init_2string                    CUR _Vr2_Astrs._s50
#define init_3string                    CUR _Vr2_Astrs._s51
#define init_file                       CUR _Vr2_Astrs._s52
#define insert_character                CUR _Vr2_Astrs._s53
#define insert_line                     CUR _Vr2_Astrs._s54
#define insert_padding                  CUR _Vr2_Astrs._s55
#define key_backspace                   CUR _Vr2_Astrs._s56
#define key_catab                       CUR _Vr2_Astrs._s57
#define key_clear                       CUR _Vr2_Astrs._s58
#define key_ctab                        CUR _Vr2_Astrs._s59
#define key_dc                          CUR _Vr2_Astrs._s60
#define key_dl                          CUR _Vr2_Astrs._s61
#define key_down                        CUR _Vr2_Astrs._s62
#define key_eic                         CUR _Vr2_Astrs._s63
#define key_eol                         CUR _Vr2_Astrs._s64
#define key_eos                         CUR _Vr2_Astrs._s65
#define key_f0                          CUR _Vr2_Astrs._s66
#define key_f1                          CUR _Vr2_Astrs._s67
#define key_f10                         CUR _Vr2_Astrs._s68
#define key_f2                          CUR _Vr2_Astrs._s69
#define key_f3                          CUR _Vr2_Astrs._s70
#define key_f4                          CUR _Vr2_Astrs._s71
#define key_f5                          CUR _Vr2_Astrs._s72
#define key_f6                          CUR _Vr2_Astrs._s73
#define key_f7                          CUR _Vr2_Astrs._s74
#define key_f8                          CUR _Vr2_Astrs._s75
#define key_f9                          CUR _Vr2_Astrs._s76
#define key_home                        CUR _Vr2_Astrs._s77
#define key_ic                          CUR _Vr2_Astrs._s78
#define key_il                          CUR _Vr2_Astrs._s79
#define key_left                        CUR _Vr2_Astrs._s80
#define key_ll                          CUR _Vr2_Astrs._s81
#define key_npage                       CUR _Vr2_Astrs._s82
#define key_ppage                       CUR _Vr2_Astrs._s83
#define key_right                       CUR _Vr2_Astrs._s84
#define key_sf                          CUR _Vr2_Astrs._s85
#define key_sr                          CUR _Vr2_Astrs._s86
#define key_stab                        CUR _Vr2_Astrs._s87
#define key_up                          CUR _Vr2_Astrs._s88
#define keypad_local                    CUR _Vr2_Astrs._s89
#define keypad_xmit                     CUR _Vr2_Astrs._s90
#define lab_f0                          CUR _Vr2_Astrs._s91
#define lab_f1                          CUR _Vr2_Astrs._s92
#define lab_f10                         CUR _Vr2_Astrs._s93
#define lab_f2                          CUR _Vr2_Astrs._s94
#define lab_f3                          CUR _Vr2_Astrs._s95
#define lab_f4                          CUR _Vr2_Astrs._s96
#define lab_f5                          CUR _Vr2_Astrs._s97
#define lab_f6                          CUR _Vr2_Astrs._s98
#define lab_f7                          CUR _Vr2_Astrs._s99
#define lab_f8                          CUR _Vr2_Astrs._s100
#define lab_f9                          CUR _Vr2_Bstrs._s101
#define meta_off                        CUR _Vr2_Bstrs._s102
#define meta_on                         CUR _Vr2_Bstrs._s103
#define newline                         CUR _Vr2_Bstrs._s104
#define pad_char                        CUR _Vr2_Bstrs._s105
#define parm_dch                        CUR _Vr2_Bstrs._s106
#define parm_delete_line                CUR _Vr2_Bstrs._s107
#define parm_down_cursor                CUR _Vr2_Bstrs._s108
#define parm_ich                        CUR _Vr2_Bstrs._s109
#define parm_index                      CUR _Vr2_Bstrs._s110
#define parm_insert_line                CUR _Vr2_Bstrs._s111
#define parm_left_cursor                CUR _Vr2_Bstrs._s112
#define parm_right_cursor               CUR _Vr2_Bstrs._s113
#define parm_rindex                     CUR _Vr2_Bstrs._s114
#define parm_up_cursor                  CUR _Vr2_Bstrs._s115
#define pkey_key                        CUR _Vr2_Bstrs._s116
#define pkey_local                      CUR _Vr2_Bstrs._s117
#define pkey_xmit                       CUR _Vr2_Bstrs._s118
#define print_screen                    CUR _Vr2_Bstrs._s119
#define prtr_off                        CUR _Vr2_Bstrs._s120
#define prtr_on                         CUR _Vr2_Bstrs._s121
#define repeat_char                     CUR _Vr2_Bstrs._s122
#define reset_1string                   CUR _Vr2_Bstrs._s123
#define reset_2string                   CUR _Vr2_Bstrs._s124
#define reset_3string                   CUR _Vr2_Bstrs._s125
#define reset_file                      CUR _Vr2_Bstrs._s126
#define restore_cursor                  CUR _Vr2_Bstrs._s127
#define row_address                     CUR _Vr2_Bstrs._s128
#define save_cursor                     CUR _Vr2_Bstrs._s129
#define scroll_forward                  CUR _Vr2_Bstrs._s130
#define scroll_reverse                  CUR _Vr2_Bstrs._s131
#define set_attributes                  CUR _Vr2_Bstrs._s132
#define set_tab                         CUR _Vr2_Bstrs._s133
#define set_window                      CUR _Vr2_Bstrs._s134
#define tab                             CUR _Vr2_Bstrs._s135
#define to_status_line                  CUR _Vr2_Bstrs._s136
#define underline_char                  CUR _Vr2_Bstrs._s137
#define up_half_line                    CUR _Vr2_Bstrs._s138
#define init_prog                       CUR _Vr2_Bstrs._s139
#define key_a1                          CUR _Vr2_Bstrs._s140
#define key_a3                          CUR _Vr2_Bstrs._s141
#define key_b2                          CUR _Vr2_Bstrs._s142
#define key_c1                          CUR _Vr2_Bstrs._s143
#define key_c3                          CUR _Vr2_Bstrs._s144
#define prtr_non                        CUR _Vr2_Bstrs._s145
#define char_padding                    CURS strs2._char_padding
#define acs_chars                       CURS strs2._acs_chars
#define plab_norm                       CURS strs2._plab_norm
#define key_btab                        CURS strs2._ky_btab
#define enter_xon_mode                  CURS strs2._entr_xon_mode
#define exit_xon_mode                   CURS strs2._exit_xon_mode
#define enter_am_mode                   CURS strs2._entr_am_mode
#define exit_am_mode                    CURS strs2._exit_am_mode
#define xon_character                   CURS strs2._xon_character
#define xoff_character                  CURS strs2._xoff_character
#define ena_acs                         CURS strs2._ena_acs
#define label_on                        CURS strs2._labl_on
#define label_off                       CURS strs2._labl_off
#define key_beg                         CURS strs2._ky_beg
#define key_cancel                      CURS strs2._ky_cancel
#define key_close                       CURS strs2._ky_close
#define key_command                     CURS strs2._ky_command
#define key_copy                        CURS strs2._ky_copy
#define key_create                      CURS strs2._ky_create
#define key_end                         CURS strs2._ky_end
#define key_enter                       CURS strs2._ky_enter
#define key_exit                        CURS strs2._ky_exit
#define key_find                        CURS strs2._ky_find
#define key_help                        CURS strs2._ky_help
#define key_mark                        CURS strs2._ky_mark
#define key_message                     CURS strs2._ky_message
#define key_move                        CURS strs2._ky_move
#define key_next                        CURS strs2._ky_next
#define key_open                        CURS strs2._ky_open
#define key_options                     CURS strs2._ky_options
#define key_previous                    CURS strs2._ky_previous
#define key_print                       CURS strs2._ky_print
#define key_redo                        CURS strs2._ky_redo
#define key_reference                   CURS strs2._ky_reference
#define key_refresh                     CURS strs2._ky_refresh
#define key_replace                     CURS strs2._ky_replace
#define key_restart                     CURS strs2._ky_restart
#define key_resume                      CURS strs2._ky_resume
#define key_save                        CURS strs2._ky_save
#define key_suspend                     CURS strs2._ky_suspend
#define key_undo                        CURS strs2._ky_undo
#define key_sbeg                        CURS strs2._ky_sbeg
#define key_scancel                     CURS strs2._ky_scancel
#define key_scommand                    CURS strs2._ky_scommand
#define key_scopy                       CURS strs2._ky_scopy
#define key_screate                     CURS strs2._ky_screate
#define key_sdc                         CURS strs2._ky_sdc
#define key_sdl                         CURS strs2._ky_sdl
#define key_select                      CURS strs2._ky_select
#define key_send                        CURS strs2._ky_send
#define key_seol                        CURS strs2._ky_seol
#define key_sexit                       CURS strs2._ky_sexit
#define key_sfind                       CURS strs2._ky_sfind
#define key_shelp                       CURS strs2._ky_shelp
#define key_shome                       CURS strs2._ky_shome
#define key_sic                         CURS strs3._ky_sic
#define key_sleft                       CURS strs3._ky_sleft
#define key_smessage                    CURS strs3._ky_smessage
#define key_smove                       CURS strs3._ky_smove
#define key_snext                       CURS strs3._ky_snext
#define key_soptions                    CURS strs3._ky_soptions
#define key_sprevious                   CURS strs3._ky_sprevious
#define key_sprint                      CURS strs3._ky_sprint
#define key_sredo                       CURS strs3._ky_sredo
#define key_sreplace                    CURS strs3._ky_sreplace
#define key_sright                      CURS strs3._ky_sright
#define key_srsume                      CURS strs3._ky_srsume
#define key_ssave                       CURS strs3._ky_ssave
#define key_ssuspend                    CURS strs3._ky_ssuspend
#define key_sundo                       CURS strs3._ky_sundo
#define req_for_input                   CURS strs3._req_for_input
#define key_f11                         CURS strs3._ky_f11
#define key_f12                         CURS strs3._ky_f12
#define key_f13                         CURS strs3._ky_f13
#define key_f14                         CURS strs3._ky_f14
#define key_f15                         CURS strs3._ky_f15
#define key_f16                         CURS strs3._ky_f16
#define key_f17                         CURS strs3._ky_f17
#define key_f18                         CURS strs3._ky_f18
#define key_f19                         CURS strs3._ky_f19
#define key_f20                         CURS strs3._ky_f20
#define key_f21                         CURS strs3._ky_f21
#define key_f22                         CURS strs3._ky_f22
#define key_f23                         CURS strs3._ky_f23
#define key_f24                         CURS strs3._ky_f24
#define key_f25                         CURS strs3._ky_f25
#define key_f26                         CURS strs3._ky_f26
#define key_f27                         CURS strs3._ky_f27
#define key_f28                         CURS strs3._ky_f28
#define key_f29                         CURS strs3._ky_f29
#define key_f30                         CURS strs3._ky_f30
#define key_f31                         CURS strs3._ky_f31
#define key_f32                         CURS strs3._ky_f32
#define key_f33                         CURS strs3._ky_f33
#define key_f34                         CURS strs3._ky_f34
#define key_f35                         CURS strs3._ky_f35
#define key_f36                         CURS strs3._ky_f36
#define key_f37                         CURS strs3._ky_f37
#define key_f38                         CURS strs3._ky_f38
#define key_f39                         CURS strs3._ky_f39
#define key_f40                         CURS strs3._ky_f40
#define key_f41                         CURS strs3._ky_f41
#define key_f42                         CURS strs3._ky_f42
#define key_f43                         CURS strs3._ky_f43
#define key_f44                         CURS strs3._ky_f44
#define key_f45                         CURS strs3._ky_f45
#define key_f46                         CURS strs3._ky_f46
#define key_f47                         CURS strs3._ky_f47
#define key_f48                         CURS strs3._ky_f48
#define key_f49                         CURS strs3._ky_f49
#define key_f50                         CURS strs3._ky_f50
#define key_f51                         CURS strs3._ky_f51
#define key_f52                         CURS strs3._ky_f52
#define key_f53                         CURS strs3._ky_f53
#define key_f54                         CURS strs3._ky_f54
#define key_f55                         CURS strs3._ky_f55
#define key_f56                         CURS strs3._ky_f56
#define key_f57                         CURS strs3._ky_f57
#define key_f58                         CURS strs3._ky_f58
#define key_f59                         CURS strs3._ky_f59
#define key_f60                         CURS strs3._ky_f60
#define key_f61                         CURS strs3._ky_f61
#define key_f62                         CURS strs3._ky_f62
#define key_f63                         CURS strs3._ky_f63
#define clr_bol                         CURS strs3._clr_bol
#define clear_margins                   CURS strs3._clear_margins
#define set_left_margin                 CURS strs3._set_left_margin
#define set_right_margin                CURS strs3._set_right_margin
#define label_format                    CURS strs3._labl_format
#define set_clock                       CURS strs3._set_clock
#define display_clock                   CURS strs3._display_clock
#define remove_clock                    CURS strs3._remove_clock
#define create_window                   CURS strs3._create_window
#define goto_window                     CURS strs3._goto_window
#define hangup                          CURS strs3._hangup
#define dial_phone                      CURS strs3._dial_phone
#define quick_dial                      CURS strs3._quick_dial
#define tone                            CURS strs3._tone
#define pulse                           CURS strs3._pulse
#define flash_hook                      CURS strs3._flash_hook
#define fixed_pause                     CURS strs3._fixed_pause
#define wait_tone                       CURS strs3._wait_tone
#define user0                           CURS strs3._user0
#define user1                           CURS strs3._user1
#define user2                           CURS strs3._user2
#define user3                           CURS strs3._user3
#define user4                           CURS strs3._user4
#define user5                           CURS strs3._user5
#define user6                           CURS strs3._user6
#define user7                           CURS strs3._user7
#define user8                           CURS strs3._user8
#define user9                           CURS strs3._user9
#define orig_pair                       CURS strs3._orig_pair
#define orig_colors                     CURS strs3._orig_colors
#define initialize_color                CURS strs3._initialize_color
#define initialize_pair                 CURS strs4._initialize_pair
#define set_color_pair                  CURS strs4._set_color_pair
#define set_foreground                  CURS strs4._set_foreground
#define set_background                  CURS strs4._set_background
#define memory_lock                     CURS strs4._mem_lock
#define memory_unlock                   CURS strs4._mem_unlock
#define change_char_pitch               CURS strs4._change_char_pitch
#define change_line_pitch               CURS strs4._change_line_pitch
#define change_res_horz                 CURS strs4._change_res_horz
#define change_res_vert                 CURS strs4._change_res_vert
#define define_char                     CURS strs4._define_char
#define enter_doublewide_mode           CURS strs4._entr_doublewide_mode
#define enter_draft_quality             CURS strs4._entr_draft_quality
#define enter_italics_mode              CURS strs4._entr_italics_mode
#define enter_leftward_mode             CURS strs4._entr_leftward_mode
#define enter_micro_mode                CURS strs4._entr_micro_mode
#define enter_near_letter_quality               CURS strs4._entr_near_letter_quality
#define enter_normal_quality            CURS strs4._entr_normal_quality
#define enter_shadow_mode               CURS strs4._entr_shadow_mode
#define enter_subscript_mode            CURS strs4._entr_subscript_mode
#define enter_superscript_mode          CURS strs4._entr_superscript_mode
#define enter_upward_mode               CURS strs4._entr_upward_mode
#define exit_doublewide_mode            CURS strs4._exit_doublewide_mode
#define exit_italics_mode               CURS strs4._exit_italics_mode
#define exit_leftward_mode              CURS strs4._exit_leftward_mode
#define exit_micro_mode                 CURS strs4._exit_micro_mode
#define exit_shadow_mode                CURS strs4._exit_shadow_mode
#define exit_subscript_mode             CURS strs4._exit_subscript_mode
#define exit_superscript_mode           CURS strs4._exit_superscript_mode
#define exit_upward_mode                CURS strs4._exit_upward_mode
#define micro_column_address            CURS strs4._micro_column_address
#define micro_down                      CURS strs4._micro_down
#define micro_left                      CURS strs4._micro_left
#define micro_right                     CURS strs4._micro_right
#define micro_row_address               CURS strs4._micro_row_address
#define micro_up                        CURS strs4._micro_up
#define order_of_pins                   CURS strs4._order_of_pins
#define parm_down_micro                 CURS strs4._prm_down_micro
#define parm_left_micro                 CURS strs4._prm_left_micro
#define parm_right_micro                CURS strs4._prm_right_micro
#define parm_up_micro                   CURS strs4._prm_up_micro
#define select_char_set                 CURS strs4._select_char_set
#define set_bottom_margin               CURS strs4._set_bottom_margin
#define set_bottom_margin_parm          CURS strs4._set_bottom_margin_parm
#define set_left_margin_parm            CURS strs4._set_left_margin_parm
#define set_right_margin_parm           CURS strs4._set_right_margin_parm
#define set_top_margin                  CURS strs4._set_top_margin
#define set_top_margin_parm             CURS strs4._set_top_margin_parm
#define start_bit_image                 CURS strs4._start_bit_image
#define start_char_set_def              CURS strs4._start_char_set_def
#define stop_bit_image                  CURS strs4._stop_bit_image
#define stop_char_set_def               CURS strs4._stop_char_set_def
#define subscript_characters            CURS strs4._subscript_characters
#define superscript_characters          CURS strs4._superscript_characters
#define these_cause_cr                  CURS strs4._these_cause_cr
#define zero_motion                     CURS strs4._zero_motion
#define char_set_names                  CURS strs4._char_set_names

typedef char *charptr;
struct strs {
    charptr
        _back_tab,              /* Back tab */
        _bell,                  /* Audible signal (bell) */
        _carriage_return,       /* Carriage return (*) */
        _change_scroll_region,  /* change to lines #1 thru #2 (vt100) (G) */
        _clear_all_tabs,        /* Clear all tab stops. */
        _clear_screen,          /* Clear screen (*) */
        _clr_eol,               /* Clear to end of line */
        _clr_eos,               /* Clear to end of display (*) */
        _column_address,        /* Set cursor column (G) */
        _command_character,     /* Term. settable cmd char in prototype */
        _crsr_address,          /* Cursor motion to row #1 col #2 (G) */
        _crsr_down,             /* Down one line */
        _crsr_home,             /* Home cursor (if no cup) */
        _crsr_invisible,        /* Make cursor invisible */
        _crsr_left,             /* Move cursor left one space. */
        _crsr_mem_address,      /* Memory relative cursor addressing. */
        _crsr_normal,           /* Make cursor appear normal (undo vs/vi) */
        _crsr_right,            /* Non-destructive space (cursor right) */
        _crsr_to_ll,            /* Last line, first column (if no cup) */
        _crsr_up,               /* Upline (cursor up) */
        _crsr_visible,          /* Make cursor very visible */
        _dlt_character, /* Delete character (*) */
        _dlt_line,              /* Delete line (*) */
        _dis_status_line,       /* Disable status line */
        _down_half_line,        /* Half-line down (forward 1/2 linefeed) */
        _entr_alt_charset_mode, /* Start alternate character set */
        _entr_blink_mode,       /* Turn on blinking */
        _entr_bold_mode,        /* Turn on bold (extra bright) mode */
        _entr_ca_mode,          /* String to begin programs that use cup */
        _entr_delete_mode,      /* Delete mode (enter) */
        _entr_dim_mode,         /* Turn on half-bright mode */
        _entr_insert_mode,      /* Insert mode (enter); */
        _entr_secure_mode,      /* Turn on blank mode (chars invisible) */
        _entr_protected_mode,   /* Turn on protected mode */
        _entr_reverse_mode,     /* Turn on reverse video mode */
        _entr_standout_mode,    /* Begin stand out mode */
        _entr_underline_mode,   /* Start underscore mode */
        _erase_chars,           /* Erase #1 characters (G) */
        _exit_alt_charset_mode, /* End alternate character set */
        _exit_attribute_mode,   /* Turn off all attributes */
        _exit_ca_mode,          /* String to end programs that use cup */
        _exit_delete_mode,      /* End delete mode */
        _exit_insert_mode,      /* End insert mode; */
        _exit_standout_mode,    /* End stand out mode */
        _exit_underline_mode,   /* End underscore mode */
        _flash_screen,          /* Visible bell (may not move cursor) */
        _form_feed,             /* Hardcopy terminal page eject (*) */
        _from_status_line,      /* Return from status line */
        _init_1string,          /* Terminal initialization string */
        _init_2string,          /* Terminal initialization string */
        _init_3string,          /* Terminal initialization string */
        _init_file,             /* Name of file containing is */
        _ins_character, /* Insert character */
        _ins_line,              /* Add new blank line (*) */
        _ins_padding,           /* Insert pad after character inserted (*) */
        _ky_backspace,          /* KEY_BACKSPACE, 0407, Sent by backspace key */
        _ky_catab,              /* KEY_CATAB, 0526, Sent by clear-all-tabs key. */
        _ky_clear,              /* KEY_CLEAR, 0515, Sent by clear screen or erase key. */
        _ky_ctab,               /* KEY_CTAB, 0525, Sent by clear-tab key */
        _ky_dc,                 /* KEY_DC, 0512, Sent by delete character key. */
        _ky_dl,                 /* KEY_DL, 0510, Sent by delete line key. */
        _ky_down,               /* KEY_DOWN, 0402, Sent by terminal down arrow key */
        _ky_eic,                /* KEY_EIC, 0514, Sent by rmir or smir in insert mode. */
        _ky_eol,                /* KEY_EOL, 0517, Sent by clear-to-end-of-line key. */
        _ky_eos,                /* KEY_EOS, 0516, Sent by clear-to-end-of-screen key. */
        _ky_f0,                 /* KEY_F(0), 0410, function key f0. */
        _ky_f1,                 /* KEY_F(1), 0411, function key f1. */
        _ky_f10,                /* KEY_F(10), 0422, function key f10. */
        _ky_f2,                 /* KEY_F(2), 0412, function key f2. */
        _ky_f3,                 /* KEY_F(3), 0413, function key f3. */
        _ky_f4,                 /* KEY_F(4), 0414, function key f4. */
        _ky_f5,                 /* KEY_F(5), 0415, function key f5. */
        _ky_f6,                 /* KEY_F(6), 0416, function key f6. */
        _ky_f7,                 /* KEY_F(7), 0417, function key f7. */
        _ky_f8,                 /* KEY_F(8), 0420, function key f8. */
        _ky_f9,                 /* KEY_F(9), 0421, function key f9. */
        _ky_home,               /* KEY_HOME, 0406, Sent by home key. */
        _ky_ic,                 /* KEY_IC, 0513, Sent by ins char/enter ins mode key. */
        _ky_il,                 /* KEY_IL, 0511, Sent by insert line. */
        _ky_left,               /* KEY_LEFT, 0404, Sent by terminal left arrow key */
        _ky_ll,                 /* KEY_LL, 0533, Sent by home-down key */
        _ky_npage,              /* KEY_NPAGE, 0522, Sent by next-page key */
        _ky_ppage,              /* KEY_PPAGE, 0523, Sent by previous-page key */
        _ky_right,              /* KEY_RIGHT, 0405, Sent by terminal right arrow key */
        _ky_sf,                 /* KEY_SF, 0520, Sent by scroll-forward/down key */
        _ky_sr,                 /* KEY_SR, 0521, Sent by scroll-backward/up key */
        _ky_stab,               /* KEY_STAB, 0524, Sent by set-tab key */
        _ky_up,                 /* KEY_UP, 0403, Sent by terminal up arrow key */
        _kpad_local,            /* Out of "keypad transmit" mode */
        _kpad_xmit,             /* Put terminal in "keypad transmit" mode */
        _lab_f0,                /* Labels on function key f0 if not f0 */
        _lab_f1,                /* Labels on function key f1 if not f1 */
        _lab_f10,               /* Labels on function key f10 if not f10 */
        _lab_f2,                /* Labels on function key f2 if not f2 */
        _lab_f3,                /* Labels on function key f3 if not f3 */
        _lab_f4,                /* Labels on function key f4 if not f4 */
        _lab_f5,                /* Labels on function key f5 if not f5 */
        _lab_f6,                /* Labels on function key f6 if not f6 */
        _lab_f7,                /* Labels on function key f7 if not f7 */
        _lab_f8;                        /* Labels on function key f8 if not f8 */
};

struct strs2 {
    charptr
        _lab_f9,                /* Labels on function key f9 if not f9 */
        _meta_off,              /* Turn off "meta mode" */
        _meta_on,               /* Turn on "meta mode" (8th bit) */
        _newline,               /* Newline (behaves like cr followed by lf) */
        _pad_char,              /* Pad character (rather than null) */
        _prm_dch,               /* Delete #1 chars (G*) */
        _prm_delete_line,       /* Delete #1 lines (G*) */
        _prm_down_cursor,       /* Move cursor down #1 lines. (G*) */
        _prm_ich,               /* Insert #1 blank chars (G*) */
        _prm_index,             /* Scroll forward #1 lines. (G) */
        _prm_insert_line,       /* Add #1 new blank lines (G*) */
        _prm_left_cursor,       /* Move cursor left #1 spaces (G) */
        _prm_right_cursor,      /* Move cursor right #1 spaces. (G*) */
        _prm_rindex,            /* Scroll backward #1 lines. (G) */
        _prm_up_cursor,         /* Move cursor up #1 lines. (G*) */
        _pkey_key,              /* Prog funct key #1 to type string #2 */
        _pkey_local,            /* Prog funct key #1 to execute string #2 */
        _pkey_xmit,             /* Prog funct key #1 to xmit string #2 */
        _print_screen,          /* Print contents of the screen */
        _prtr_off,              /* Turn off the printer */
        _prtr_on,               /* Turn on the printer */
        _repeat_char,           /* Repeat char #1 #2 times.  (G*) */
        _reset_1string,         /* Reset terminal completely to sane modes. */
        _reset_2string,         /* Reset terminal completely to sane modes. */
        _reset_3string,         /* Reset terminal completely to sane modes. */
        _reset_file,            /* Name of file containing reset string. */
        _restore_cursor,        /* Restore cursor to position of last sc. */
        _row_address,           /* Like hpa but sets row. (G) */
        _save_cursor,           /* Save cursor position. */
        _scrll_forward,         /* Scroll text up */
        _scrll_reverse,         /* Scroll text down */
        _set_attributes,        /* Define the video attributes (G9) */
        _set_tab,               /* Set a tab in all rows, current column. */
        _set_window,            /* Current window is lines #1-#2 cols #3-#4 */
        _tab,                   /* Tab to next 8 space hardware tab stop. */
        _to_status_line,        /* Go to status line, col #1 */
        _underline_char,        /* Underscore one char and move past it */
        _up_half_line,          /* Half-line up (reverse 1/2 linefeed) */
        _init_prog,             /* Path name of program for init. */
        _ky_a1,                 /* KEY_A1, 0534, Upper left of keypad */
        _ky_a3,                 /* KEY_A3, 0535, Upper right of keypad */
        _ky_b2,                 /* KEY_B2, 0536, Center of keypad */
        _ky_c1,                 /* KEY_C1, 0537, Lower left of keypad */
        _ky_c3,                 /* KEY_C3, 0540, Lower right of keypad */
        _prtr_non,              /* Turn on the printer for #1 bytes. */
        _char_padding,          /* Like ip but when in replace mode */
        _acs_chars,             /* Graphic charset pairs aAbBcC - def=vt100 */
        _plab_norm,             /* Prog label #1 to show string #2 */
        _ky_btab,               /* KEY_BTAB, 0541, Back tab key */
        _entr_xon_mode,         /* Turn on xon/xoff handshaking */
        _exit_xon_mode,         /* Turn off xon/xoff handshaking */
        _entr_am_mode,          /* Turn on automatic margins */
        _exit_am_mode,          /* Turn off automatic margins */
        _xon_character,         /* X-on character */
        _xoff_character,        /* X-off character */
        _ena_acs,               /* Enable alternate char set */
        _labl_on,               /* Turn on soft labels */
        _labl_off,              /* Turn off soft labels */
        _ky_beg,                /* KEY_BEG, 0542, beg(inning) key */
        _ky_cancel,             /* KEY_CANCEL, 0543, cancel key */
        _ky_close,              /* KEY_CLOSE, 0544, close key */
        _ky_command,            /* KEY_COMMAND, 0545, cmd (command) key */
        _ky_copy,               /* KEY_COPY, 0546, copy key */
        _ky_create,             /* KEY_CREATE, 0547, create key */
        _ky_end,                /* KEY_END, 0550, end key */
        _ky_enter,              /* KEY_ENTER, 0527, Enter/send (unreliable) */
        _ky_exit,               /* KEY_EXIT, 0551, exit key */
        _ky_find,               /* KEY_FIND, 0552, find key */
        _ky_help,               /* KEY_HELP, 0553, help key */
        _ky_mark,               /* KEY_MARK, 0554, mark key */
        _ky_message,            /* KEY_MESSAGE, 0555, message key */
        _ky_move,               /* KEY_MOVE, 0556, move key */
        _ky_next,               /* KEY_NEXT, 0557, next object key */
        _ky_open,               /* KEY_OPEN, 0560, open key */
        _ky_options,            /* KEY_OPTIONS, 0561, options key */
        _ky_previous,           /* KEY_PREVIOUS, 0562, previous object key */
        _ky_print,              /* KEY_PRINT, 0532, print or copy */
        _ky_redo,               /* KEY_REDO, 0563, redo key */
        _ky_reference,          /* KEY_REFERENCE, 0564, ref(erence) key */
        _ky_refresh,            /* KEY_REFRESH, 0565, refresh key */
        _ky_replace,            /* KEY_REPLACE, 0566, replace key */
        _ky_restart,            /* KEY_RESTART, 0567, restart key */
        _ky_resume,             /* KEY_RESUME, 0570, resume key */
        _ky_save,               /* KEY_SAVE, 0571, save key */
        _ky_suspend,            /* KEY_SUSPEND, 0627, suspend key */
        _ky_undo,               /* KEY_UNDO, 0630, undo key */
        _ky_sbeg,               /* KEY_SBEG, 0572, shifted beginning key */
        _ky_scancel,            /* KEY_SCANCEL, 0573, shifted cancel key */
        _ky_scommand,           /* KEY_SCOMMAND, 0574, shifted command key */
        _ky_scopy,              /* KEY_SCOPY, 0575, shifted copy key */
        _ky_screate,            /* KEY_SCREATE, 0576, shifted create key */
        _ky_sdc,                /* KEY_SDC, 0577, shifted delete char key */
        _ky_sdl,                /* KEY_SDL, 0600, shifted delete line key */
        _ky_select,             /* KEY_SELECT, 0601, select key */
        _ky_send,               /* KEY_SEND, 0602, shifted end key */
        _ky_seol,               /* KEY_SEOL, 0603, shifted clear line key */
        _ky_sexit,              /* KEY_SEXIT, 0604, shifted exit key */
        _ky_sfind,              /* KEY_SFIND, 0605, shifted find key */
        _ky_shelp,              /* KEY_SHELP, 0606, shifted help key */
        _ky_shome;              /* KEY_SHOME, 0607, shifted home key */
};

struct strs3 {
    charptr
        _ky_sic,                /* KEY_SIC, 0610, shifted input key */
        _ky_sleft,              /* KEY_SLEFT, 0611, shifted left arrow key */
        _ky_smessage,           /* KEY_SMESSAGE, 0612, shifted message key */
        _ky_smove,              /* KEY_SMOVE, 0613, shifted move key */
        _ky_snext,              /* KEY_SNEXT, 0614, shifted next key */
        _ky_soptions,           /* KEY_SOPTIONS, 0615, shifted options key */
        _ky_sprevious,          /* KEY_SPREVIOUS, 0616, shifted prev key */
        _ky_sprint,             /* KEY_SPRINT, 0617, shifted print key */
        _ky_sredo,              /* KEY_SREDO, 0620, shifted redo key */
        _ky_sreplace,           /* KEY_SREPLACE, 0621, shifted replace key */
        _ky_sright,             /* KEY_SRIGHT, 0622, shifted right arrow */
        _ky_srsume,             /* KEY_SRSUME, 0623, shifted resume key */
        _ky_ssave,              /* KEY_SSAVE, 0624, shifted save key */
        _ky_ssuspend,           /* KEY_SSUSPEND, 0625, shifted suspend key */
        _ky_sundo,              /* KEY_SUNDO, 0626, shifted undo key */
        _req_for_input,         /* send next input char (for ptys) */
        _ky_f11,                /* KEY_F(11), 0423, function key f11. */
        _ky_f12,                /* KEY_F(12), 0424, function key f12. */
        _ky_f13,                /* KEY_F(13), 0425, function key f13. */
        _ky_f14,                /* KEY_F(14), 0426, function key f14. */
        _ky_f15,                /* KEY_F(15), 0427, function key f15. */
        _ky_f16,                /* KEY_F(16), 0430, function key f16. */
        _ky_f17,                /* KEY_F(17), 0431, function key f17. */
        _ky_f18,                /* KEY_F(18), 0432, function key f18. */
        _ky_f19,                /* KEY_F(19), 0433, function key f19. */
        _ky_f20,                /* KEY_F(20), 0434, function key f20. */
        _ky_f21,                /* KEY_F(21), 0435, function key f21. */
        _ky_f22,                /* KEY_F(22), 0436, function key f22. */
        _ky_f23,                /* KEY_F(23), 0437, function key f23. */
        _ky_f24,                /* KEY_F(24), 0440, function key f24. */
        _ky_f25,                /* KEY_F(25), 0441, function key f25. */
        _ky_f26,                /* KEY_F(26), 0442, function key f26. */
        _ky_f27,                /* KEY_F(27), 0443, function key f27. */
        _ky_f28,                /* KEY_F(28), 0444, function key f28. */
        _ky_f29,                /* KEY_F(29), 0445, function key f29. */
        _ky_f30,                /* KEY_F(30), 0446, function key f30. */
        _ky_f31,                /* KEY_F(31), 0447, function key f31. */
        _ky_f32,                /* KEY_F(32), 0450, function key f32. */
        _ky_f33,                /* KEY_F(33), 0451, function key f33. */
        _ky_f34,                /* KEY_F(34), 0452, function key f34. */
        _ky_f35,                /* KEY_F(35), 0453, function key f35. */
        _ky_f36,                /* KEY_F(36), 0454, function key f36. */
        _ky_f37,                /* KEY_F(37), 0455, function key f37. */
        _ky_f38,                /* KEY_F(38), 0456, function key f38. */
        _ky_f39,                /* KEY_F(39), 0457, function key f39. */
        _ky_f40,                /* KEY_F(40), 0460, function key f40. */
        _ky_f41,                /* KEY_F(41), 0461, function key f41. */
        _ky_f42,                /* KEY_F(42), 0462, function key f42. */
        _ky_f43,                /* KEY_F(43), 0463, function key f43. */
        _ky_f44,                /* KEY_F(44), 0464, function key f44. */
        _ky_f45,                /* KEY_F(45), 0465, function key f45. */
        _ky_f46,                /* KEY_F(46), 0466, function key f46. */
        _ky_f47,                /* KEY_F(47), 0467, function key f47. */
        _ky_f48,                /* KEY_F(48), 0470, function key f48. */
        _ky_f49,                /* KEY_F(49), 0471, function key f49. */
        _ky_f50,                /* KEY_F(50), 0472, function key f50. */
        _ky_f51,                /* KEY_F(51), 0473, function key f51. */
        _ky_f52,                /* KEY_F(52), 0474, function key f52. */
        _ky_f53,                /* KEY_F(53), 0475, function key f53. */
        _ky_f54,                /* KEY_F(54), 0476, function key f54. */
        _ky_f55,                /* KEY_F(55), 0477, function key f55. */
        _ky_f56,                /* KEY_F(56), 0500, function key f56. */
        _ky_f57,                /* KEY_F(57), 0501, function key f57. */
        _ky_f58,                /* KEY_F(58), 0502, function key f58. */
        _ky_f59,                /* KEY_F(59), 0503, function key f59. */
        _ky_f60,                /* KEY_F(60), 0504, function key f60. */
        _ky_f61,                /* KEY_F(61), 0505, function key f61. */
        _ky_f62,                /* KEY_F(62), 0506, function key f62. */
        _ky_f63,                /* KEY_F(63), 0507, function key f63. */
        _clr_bol,               /* Clear to beginning of line, inclusive */
        _clear_margins,         /* Clear left and right soft margins */
        _set_left_margin,       /* Set soft left margin */
        _set_right_margin,      /* Set soft right margin */
        _labl_format,           /* Label format */
        _set_clock,             /* Set time-of-day clock */
        _display_clock,         /* Display time-of-day clock */
        _remove_clock,          /* Remove time-of-day clock */
        _create_window,         /* Define win #1 to go from #2,#3 to #4,#5 */
        _goto_window,           /* Got to window #1 */
        _hangup,                /* Hang-up phone */
        _dial_phone,            /* Dial phone number #1 */
        _quick_dial,            /* Dial phone number #1, without progress detection */
        _tone,                  /* Select touch tone dialing */
        _pulse,                 /* Select pulse dialing */
        _flash_hook,            /* Flash the switch hook */
        _fixed_pause,           /* Pause for 2-3 seconds */
        _wait_tone,             /* Wait for dial tone */
        _user0,                 /* User string 0 */
        _user1,                 /* User string 1 */
        _user2,                 /* User string 2 */
        _user3,                 /* User string 3 */
        _user4,                 /* User string 4 */
        _user5,                 /* User string 5 */
        _user6,                 /* User string 6 */
        _user7,                 /* User string 7 */
        _user8,                 /* User string 8 */
        _user9,                 /* User string 9 */
        _orig_pair,             /* Original color-pair */
        _orig_colors,           /* Original colors */
        _initialize_color;      /* Initialize the definition of color */
};

struct strs4 {
    charptr
        _initialize_pair,       /* Initialize color pair */
        _set_color_pair,        /* Set color pair        */
        _set_foreground,        /* Set foregrounf color */
        _set_background,        /* Set background color */
        _mem_lock,              /* Lock memory above cursor */
        _mem_unlock,            /* Turn memory lock off */
        _change_char_pitch,     /* Change no. characters per inch */
        _change_line_pitch,     /* Change no. lines per inch */
        _change_res_horz,       /* Change horizontal resolution */
        _change_res_vert,       /* Change vertical resolution */
        _define_char,           /* Define a character in a character set */
        _entr_doublewide_mode,  /* Enable double wide printing */
        _entr_draft_quality,    /* Set draft quality print */
        _entr_italics_mode,     /* Enable italics */
        _entr_leftward_mode,    /* Enable leftward carriage motion */
        _entr_micro_mode,       /* Enable micro motion capabilities */
        _entr_near_letter_quality,      /* Set near-letter quality print */
        _entr_normal_quality,   /* Set normal quality print */
        _entr_shadow_mode,      /* Enable shadow printing */
        _entr_subscript_mode,   /* Enable subscript printing */
        _entr_superscript_mode, /* Enable superscript printing */
        _entr_upward_mode,      /* Enable upward carriage motion */
        _exit_doublewide_mode,  /* Disable double wide printing */
        _exit_italics_mode,     /* Disable italics */
        _exit_leftward_mode,    /* Enable rightward (normal) carriage motion */
        _exit_micro_mode,       /* Disable micro motion capabilities */
        _exit_shadow_mode,      /* Disable shadow printing */
        _exit_subscript_mode,   /* Disable subscript printing */
        _exit_superscript_mode, /* Disable superscript printing */
        _exit_upward_mode,      /* Enable downward (normal) carriage motion */
        _micro_column_address,  /* Like column_address for micro adjustment */
        _micro_down,            /* Like cursor_down for micro adjustment */
        _micro_left,            /* Like cursor_left for micro adjustment */
        _micro_right,           /* Like cursor_right for micro adjustment */
        _micro_row_address,     /* Like row_address for micro adjustment */
        _micro_up,              /* Like cursor_up for micro adjustment */
        _order_of_pins,         /* Matches software bits to print-head pins */
        _prm_down_micro,        /* Like parm_down_cursor for micro adjust. */
        _prm_left_micro,        /* Like parm_left_cursor for micro adjust. */
        _prm_right_micro,       /* Like parm_right_cursor for micro adjust. */
        _prm_up_micro,          /* Like parm_up_cursor for micro adjust. */
        _select_char_set,       /* Select character set */
        _set_bottom_margin,     /* Set soft bottom margin at current line */
        _set_bottom_margin_parm,/* Set soft bottom margin */
        _set_left_margin_parm,  /* Set soft left margin */
        _set_right_margin_parm, /* Set soft right margin */
        _set_top_margin,        /* Set soft top margin at current line */
        _set_top_margin_parm,   /* Set soft top margin */
        _start_bit_image,       /* Start printing bit image graphics */
        _start_char_set_def,    /* Start definition of a character set */
        _stop_bit_image,        /* End printing bit image graphics */
        _stop_char_set_def,     /* End definition of a character set */
        _subscript_characters,  /* List of ``subscript-able'' characters */
        _superscript_characters,/* List of ``superscript-able'' characters */
        _these_cause_cr,        /* Printing any of these chars causes cr */
        _zero_motion,           /* No motion for the subsequent character */
        _char_set_names,        /* List of character set names */
        Sentinel;               /* End of strings. DO NOT MOVE! */
};

struct _bool_struct {
    char
        _auto_left_margin,      /* cub1 wraps from column 0 to last column */
        _auto_right_margin,     /* Terminal has automatic margins */
        _no_esc_ctlc,           /* Beehive (f1=escape, f2=ctrl C) */
        _ceol_standout_glitch,  /* Standout not erased by overwriting (hp) */
        _eat_newline_glitch,    /* newline ignored after 80 cols (Concept) */
        _erase_overstrike,      /* Can erase overstrikes with a blank */
        _generic_type,          /* Generic line type (e.g. dialup, switch). */
        _hard_copy,             /* Hardcopy terminal */
        _has_meta_key,          /* Has a meta key (shift, sets parity bit) */
        _has_status_line,       /* Has extra "status line" */
        _ins_null_glitch,       /* Insert mode distinguishes nulls */
        _mem_above,             /* Display may be retained above the screen */
        _mem_below,             /* Display may be retained below the screen */
        _move_insert_mode,      /* Safe to move while in insert mode */
        _move_standout_mode,    /* Safe to move in standout modes */
        _over_strike,           /* Terminal overstrikes */
        _status_line_esc_ok,    /* Escape can be used on the status line */
        _dest_tabs_magic_smso,  /* Tabs destructive, magic so char (t1061) */
        _tilde_glitch,          /* Hazeltine; can't print ~'s */
        _transparent_underline, /* underline character overstrikes */
        _xon_xoff,              /* Terminal uses xon/xoff handshaking */
        _needs_xon_xoff,        /* Padding won't work, xon/xoff required */
        _prtr_silent,           /* Printer won't echo on screen. */
        _hard_cursor,           /* Cursor is hard to see. */
        _non_rev_rmcup,         /* Smcup does not reverse rmcup. */
        _no_pad_char,           /* Pad character doesn't exist. */
        _non_dest_scroll_region,/* Scrolling region is non-destructive. */
        _can_change,            /* Can re-define existing color */
        _back_color_erase,      /* Erases screen with current background */
        _hue_lightness_saturation,      /* HLS color notation is used (Tek) */
        _ti931_glitch,          /* ti931 glitch on wrap from 80 20. */
        _col_addr_glitch,       /* Only positive motion for hpa/mhpa caps */
        _cr_cancels_micro_mode, /* Using cr turns off micro mode */
        _has_print_wheel,       /* Printer needs operator to change character set */
        _row_addr_glitch,       /* Only positive motion for vpa/mvpa caps */
        _semi_auto_right_margin,/* Printing in last column causes cr */
        _cpi_changes_res,       /* Changing char. pitch changes resolution */
        _lpi_changes_res,       /* Changing line pitch changes resolution */
        Sentinel;               /* End of bools. DO NOT MOVE! */
};

struct _num_struct {
    short
        _columns,               /* Number of columns in a line */
        _init_tabs,             /* Tabs initially every # spaces. */
        _lines,                 /* Number of lines on screen or page */
        _lines_of_memory,       /* Lines of memory if > lines.  0 => varies */
        _magic_cookie_glitch,   /* Number blank chars left by smso or rmso */
        _padding_baud_rate,     /* Lowest baud rate where padding needed */
        _virtual_terminal,      /* Virtual terminal number (CB/Unix) */
        _width_status_line,     /* # columns in status line */
        _num_labels,            /* # of labels on screen (start at 1) */
        _labl_height,           /* # rows in each label */
        _labl_width,            /* # cols in each label */
        _max_attributes,        /* max combined video attributes terminal can display */
        _maximum_windows,       /* Maximum number of defineable windows */
        _max_colors,            /* max # of color on the screen */
        _max_pairs,             /* max # of color pairs on the screen */
        _no_color_video,        /* Video attributes that cannot be used with colors */
        _buffer_capacity,       /* Number of bytes buffered before printing */
        _dot_vert_spacing,      /* Spacing of pins vertically in pins per inch */
        _dot_horz_spacing,      /* Spacing of dots horizontally in dots per inch */
        _max_micro_address,     /* Maximum value in micro_..._address */
        _max_micro_jump,        /* Maximum value in parm_..._micro */
        _micro_char_size,       /* Character step size when in micro mode */
        _micro_line_size,       /* Line step size when in micro mode */
        _number_of_pins,        /* Number of pins in print-head */
        _output_res_char,       /* Horizontal resolution in units per character */
        _output_res_line,       /* Vertical resolution in units per line */
        _output_res_horz_inch,  /* Horizontal resolution in units per inch */
        _output_res_vert_inch,  /* Vertical resolution in units per inch */
        _print_rate,            /* Print rate in characters per second */
        _wide_char_size,        /* Character step size when in double wide mode */
        Sentinel;               /* End of nums. DO NOT MOVE! */
};

struct _str_struct {
        struct strs strs;
        struct strs2 strs2;
        struct strs3 strs3;
        struct strs4 strs4;
};

#define NUM_ATTRIBUTES  9
#define UNACCESSIBLE            1
#define NO_TERMINAL             2
#define CORRUPTED               3
#define ENTRY_TOO_LONG          4
#define TERMINFO_TOO_LONG       5
#define TERM_BAD_MALLOC         6
#define NOT_READABLE            7
#define _VR2_COMPAT_CODE
#ifdef _VR2_COMPAT_CODE
struct _Vr2_Astrs {
    charptr
        _s1,  _s2,  _s3,  _s4,  _s5,  _s6,  _s7,  _s8,  _s9,  _s10,
        _s11, _s12, _s13, _s14, _s15, _s16, _s17, _s18, _s19, _s20,
        _s21, _s22, _s23, _s24, _s25, _s26, _s27, _s28, _s29, _s30,
        _s31, _s32, _s33, _s34, _s35, _s36, _s37, _s38, _s39, _s40,
        _s41, _s42, _s43, _s44, _s45, _s46, _s47, _s48, _s49, _s50,
        _s51, _s52, _s53, _s54, _s55, _s56, _s57, _s58, _s59, _s60,
        _s61, _s62, _s63, _s64, _s65, _s66, _s67, _s68, _s69, _s70,
        _s71, _s72, _s73, _s74, _s75, _s76, _s77, _s78, _s79, _s80,
        _s81, _s82, _s83, _s84, _s85, _s86, _s87, _s88, _s89, _s90,
        _s91, _s92, _s93, _s94, _s95, _s96, _s97, _s98, _s99, _s100;
};

struct _Vr2_Bstrs {
    charptr
        _s101, _s102, _s103, _s104, _s105, _s106, _s107, _s108, _s109, _s110,
        _s111, _s112, _s113, _s114, _s115, _s116, _s117, _s118, _s119, _s120,
        _s121, _s122, _s123, _s124, _s125, _s126, _s127, _s128, _s129, _s130,
        _s131, _s132, _s133, _s134, _s135, _s136, _s137, _s138, _s139, _s140,
        _s141, _s142, _s143, _s144, _s145;
};
#endif /* _VR2_COMPAT_CODE */

typedef struct {
        char *_sends;   /* Characters sent when key is pressed */
        short _keyval;  /* "char" we pass back to program */
} _KEY_MAP;

/*
 * This definition for the term struct allows the boolean, number
 * and string information to grow in the future and still allow .o
 * compatibility.
 */

struct term {
#ifdef _VR2_COMPAT_CODE
    char
        _b1,  _b2,  _b3,  _b4,  _b5,  _b6,  _b7,  _b8,  _b9,  _b10,
        _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19, _b20, _b21;
    short
        _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8;
        struct _Vr2_Astrs _Vr2_Astrs;
        struct _Vr2_Bstrs _Vr2_Bstrs;
#endif /* _VR2_COMPAT_CODE */
        short Filedes;          /* file descriptor being written to */
        SGTTY Ottyb,            /* original state of the terminal */
              Nttyb;            /* current state of the terminal */
#ifdef DIOCSETT
        struct termcb new, old; /* CB/UNIX virtual terminals */
#endif
#ifdef LTILDE
        int newlmode, oldlmode; /* BSD tty driver */
#endif
        /* end of Vr2 structure */
        struct _bool_struct *_bools;
        struct _num_struct *_nums;
        struct _str_struct *_strs;
        char *_strtab;
#ifdef FIONREAD
        long timeout;           /* for BSD halfdelay mode */
#endif
        /* end of Vr3 structure */
        chtype sgr_mode;                /* current phys. graphic rendition */
        chtype sgr_faked;               /* attributes faked by vidputs */
        int    _delay;                  /* timeout for inputs */
        int    _inputfd;                /* input file descriptor */
        int    _check_fd;               /* typeahead file descriptor */
        _KEY_MAP        **_keys,        /* key map */
                        *internal_keys; /* pointer to free key structures */
        short           _ksz,           /* size of keymap */
                        _lastkey_ordered,/* where the last ordered key is */
                        _lastmacro_ordered,/* where the last ordered macro is */
                        _first_macro;
        bool                            /* map of which chars start fn keys */
                        funckeystarter[0400];
        bool            _fl_rawmode,    /* in cbreak(=1) or raw(=2) mode */
                        fl_typeahdok,   /* ok to use typeahead */
                        _cursorstate,   /* cursor: 0=invis, 1=norm, 2=vvis */
                        _iwait;         /* true if input-pending */
        short           _regs[26];      /* tparm static registers */
#define INP_QSIZE       32
        short                           /* a place to put stuff ungetch'ed */
                        _input_queue[INP_QSIZE],
                        _ungotten;      /* # chars ungotten by ungetch() */
        char            _chars_on_queue; /* # chars on queue */
#ifdef _VR3_COMPAT_CODE
        _ochtype        *_acsmap;
        chtype          *_acs32map;     /* map of alternate char set chars */
#else /* _VR3_COMPAT_CODE */
        chtype          *_acsmap;       /* map of alternate char set chars */
#endif /* _VR3_COMPAT_CODE */
        char            *turn_on_seq[NUM_ATTRIBUTES];
        chtype          bit_vector;
        char            *cursor_seq[3];
        char            _termname[15];
        char            *turn_off_seq[3];
        chtype          check_turn_off;
        chtype          non_faked_mode;
};

typedef struct term TERMINAL;

/* allow old names for these capabilities */
#define beehive_glitch  no_esc_ctlc
#define teleray_glitch  dest_tabs_magic_smso

extern TERMINAL                 *cur_term;
extern struct _bool_struct      *cur_bools;
extern struct _num_struct       *cur_nums;
extern struct _str_struct       *cur_strs;

#ifdef SINGLE
extern TERMINAL                 _first_term;
extern struct _bool_struct      _frst_bools;
extern struct _num_struct       _frst_nums;
extern struct _str_struct       _frst_strs;

# define CUR                    _first_term.
# define CURB                   _frst_bools.
# define CURN                   _frst_nums.
# define CURS                   _frst_strs.
# define PROGTTY                _first_term.Nttyb
# define SHELLTTY               _first_term.Ottyb
#else
# define CUR                    cur_term->
# define CURB                   cur_bools->
# define CURN                   cur_nums->
# define CURS                   cur_strs->
# define PROGTTY                (cur_term->Nttyb)
# define SHELLTTY               (cur_term->Ottyb)
#endif

extern  chtype          termattrs();
extern  TERMINAL        *setcurterm(/* TERMINAL *newterminal */);

#ifdef  _VR3_COMPAT_CODE
extern  TERMINAL        *set_curterm(/* TERMINAL *newterminal */);
#endif  /* _VR3_COMPAT_CODE */

#ifndef NOMACROS
#define del_curterm     delterm
#define set_curterm     setcurterm
#endif /* NOMACROS */

extern  short   term_errno;

extern  char    *tparm(), *tgoto(), *tgetstr(), *tigetstr(),
                term_parm_err[], *term_err_strings[], *Def_term, *termname();
extern  char    *boolnames[], *boolcodes[], *boolfnames[],
                *numnames[], *numcodes[], *numfnames[],
                *strnames[], *strcodes[], *strfnames[];
extern  int     tputs(), putp(), vidputs(), vidattr();

extern  int     resetterm(), fixterm(), saveterm(), restartterm(), del_curterm(),
                delterm();

extern  void    termerr(), tinputfd();
#endif /* auto_left_margin */
termio.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)termio.h     1.1 86/05/15";
*/
/*      @(#)termio.h    1.1     */
/*      3.0 SID #       1.3     */
#include <sys/termio.h>
time.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = "@(#)time.h      1.4 89/11/14";
*/
/*      @(#)time.h      1.1     */
/*      3.0 SID #       1.2     */
struct  tm {    /* see ctime(3) */
        int     tm_sec;
        int     tm_min;
        int     tm_hour;
        int     tm_mday;
        int     tm_mon;
        int     tm_year;
        int     tm_wday;
        int     tm_yday;
        int     tm_isdst;
};
struct  iform { /* see ctime(3) */
        int     if_sec;
        int     if_min;
        int     if_hour;
        int     if_mday;
        int     if_mon;
        int     if_year;
        int     if_wday;
        int     if_time;
};
extern struct tm *gmtime(), *localtime();
extern struct iform *iformat();
extern char *ctime(), *asctime(), *itime();
extern void tzset();
extern long timezone;
extern int daylight;
extern char *tzname[];
tisam.h
/*
 *  COPYRIGHT (c) 1986, 1987, 1988, 1989, 1990, 1991, 1992 TEXAS INSTRUMENTS,
 *  INCORPORATED.  ALL  RIGHTS RESERVED.
 *
 *  COPYRIGHT (c) 1992, 1993 HEWLETT-PACKARD COMPANY.  ALL RIGHTS RESERVED.
 *
 *  @(#)tisam.h (T-ISAM) version 2.8.8  (18 February 1993)
 */
#ifndef TIINCLUDE
#define TIINCLUDE

/*==============================================================================
        MAXIMUM VALUES AND LENGTHS
==============================================================================*/
#define TIMAXFILENAME   64              /* maximum file name length */
#define TIMAXREC        0xfa00          /* maximum record length */
#define TIMAXKEY        120             /* maximum key length */
#define TIVNLEN         8               /* maximum version name length */
#define TINFIELD        8               /* number of key fields */


/*==============================================================================
        KEY DESCRIPTOR - Used by tibuild(), tiaddindex(), tistart(), and
                        tiindexinfo()
==============================================================================*/

/*----- The Key Descriptor structure -----------------------------------------*/
struct  tikeypart
{
        short   kp_start;               /* offset to part array(field) */
        short   kp_leng;                /* length of part array(field) */
        short   kp_type;                /* type of part array(field) */
};

struct  tikeydesc
{
                short           k_flags;                /* cisam flags */
                short           k_nparts;               /* number of parts */
        struct  tikeypart       k_part[TINFIELD];       /* key part array */
                short           k_flage;                /* extended flags */
                short           k_type;                 /* INTERNAL USE */
                long            k_kdid;                 /* key ID */
};

/*----- k_flags values -------------------------------------------------------*/
#define TINODUP         0x0000          /* duplicates are not allowed */
#define TIKEYDUP        0x0001          /* duplicates are allowed */
#define TIKEYCMP        0x000e          /* compress key */

/*----- k_flage values -------------------------------------------------------*/
#define TIKEYSTR        0x0001          /* (auto store) */
#define TIKEYID         0x0002          /* (id only) */
#define TIKEYNOA        0x0004          /* no ANSI currency */
#define TIKEYVAL        0x0008          /* validate key */
#define TIKEYEVN        0x0010          /* round to even length */
#define TIKEYFAS        0x0020          /* faster processing of duplicate */
                                        /*   keys.  no ANSI currency kept.*/

/*----- kp_type values and associated lengths --------------------------------*/
#define TIFCHR          0x0000          /* field is CHARTYPE */
#define TIFINT          0x0001          /* field is INTTYPE */
#define TIFLNG          0x0002          /* field is LONGTYPE */
#define TIFDBL          0x0003          /* field is DOUBLETYPE */
#define TIFFLT          0x0004          /* field is FLOATTYPE */
#define TIFDESC         0x0080          /* field is descending */

#define TILCHR          0x0001          /* length of CHARTYPE item */
#define TILINT          0x0002          /* length of INTTYPE item */
#define TILLNG          0x0004          /* length of LONGTYPE item */
#define TILFLT          0x0004          /* length of FLOATTYPE item */
#define TILDBL          0x0008          /* length of DOUBLETYPE item */


/*==============================================================================
        DICTIONARY DESCRIPTOR - Used by tiindexinfo()
==============================================================================*/

struct  tidictinfo
{
        short   di_nkeys;               /* number of user keys */
        short   di_recsize;             /* maximum data record length */
        short   di_idxsize;             /* index(device) record length */
        long    di_nrecords;            /* number of data records */
        char    di_vernum[TIVNLEN];
        char    di_idxname[TIMAXFILENAME];
};


/*==============================================================================
        FILE USAGE CONSTANTS
==============================================================================*/
/*----- Internal constants ---------------------------------------------------*/
#define TILOG           0x40000000L     /* internal */
#define TISWDAT         0x20000000L     /* internal */
#define TISWKEY         0x10000000L     /* internal */
#define TIAUDIT         0x04000000L     /* internal */
#define TIREWLOG        0x02000000L     /* internal */
#define TINOLOCK        0x00000800L     /* internal */
#define TIUNLOCK        0x00000100L     /* internal */
#define TILESS          0x00000020L     /* internal */

/*----- Used by tibuild() and tiopen() ---------------------------------------*/
#define TIINPUT         0x00000001L     /* input only */
#define TIOUTPUT        0x00000002L     /* output only */
#define TIINOUT         0x00000003L     /* input and output */

#define TIEXCLLOCK      0x00000004L     /* exclusive file access */
#define TIAUTOLOCK      0x00000008L     /* automatic locking/unlocking */
#define TIMANULOCK      0x00000010L     /* manual locking */
#define TIMULTLOCK      0x00008000L     /* automatic locking/no unlock */
#define TIWRITLOCK      0x00004000L     /* automatic lock for write/rewrite */
#define TIZEROL         0x00000000L

/*----- Used by tilock() -----------------------------------------------------*/
#define TIREADLK        TIINPUT         /* apply "read lock" to file. */
#define TIWRITLK        TIOUTPUT        /* apply "write lock" to file. */

/*----- Used by tioption() ---------------------------------------------------*/
#define TIADVLOCK       0x00002000L     /* advance currency on locked record */
#define TICOMPRESS      0x08000000L     /* compress data records */
#define TINOFREE        0x80000000L     /* don't record free space */
#define TINOEXCLLOCK    0x00001000L     /* disable exclusive opens */
#define TISLEPLOCK      0x00000200L     /* read with sleep-on-lock */

#define TIPROSAFE       TILOG                   /* integrity across aborts */
#define TIDATSAFE       (TILOG|TISWDAT)         /* data file integrity */
#define TIKEYSAFE       (TILOG|TISWDAT|TISWKEY) /* key+data file integrity */
#define TISYSSAFE       (TILOG|TISWDAT|TISWKEY) /* key+data file integrity */
#define TIREWSAFE       (TILOG|TIREWLOG)        /* slow, safe rewrites */

#define TIOPTSET        0x0001          /* Set options */
#define TIOPTGET        0x0002          /* Get options */
#define TIOPTGLOBAL     0x8000          /* Global set/get options */

/*----- Used by tiread() and tistart() ---------------------------------------*/
#define TIFIRST         0x00000001L     /* First key in current index */
#define TILAST          0x00000002L     /* Last key in current index */
#define TICURR          0x00000008L     /* Current key */
#define TIEQUAL         0x00000040L     /* Key equal to spec value */
#define TIGREAT         0x00000080L     /* Smallest key greater than spec val */
#define TIGTEQ    (TIEQUAL|TIGREAT)     /* Smallest key greater than or equal
                                                to spec value */

/*----- Used by tiread() only -----------------------------------------------*/
#define TIPREV          0x00000004L     /* Previous key */
#define TINEXT          0x00000010L     /* Next key */

#define TILOCK          0x00000100L     /* Lock record */
#define TISLOCK         0x00000200L     /* Sleep lock */


/*----- Used by tifree() only -----------------------------------------------*/
#define TIKEY           0x00000001L     /* Key File */
#define TIDAT           0x00000002L     /* Data File */

/*==============================================================================
        AUDIT TRAIL
==============================================================================*/

/*----- Commands for tiaudit() -----------------------------------------------*/
#define TIAUDSETNAME    0x0000          /* store pathname in data file  */
#define TIAUDGETNAME    0x0001          /* load pathname from data file */
#define TIAUDSTART      0x0002          /* start audit trail            */
#define TIAUDSTOP       0x0003          /* stop audit trail             */
#define TIAUDINFO       0x0004          /* audit trail status           */

/*----- Overhead struct that precedes data record in audit trail -------------*/
struct tiaudhead
{
        char    au_type[2];             /* operation type: dd, aa, rr, or ww */
        char    au_time[4];             /* time of operation                 */
        char    au_procid[2];           /* process id                        */
        char    au_userid[2];           /* user id                           */
        char    au_recnum[4];           /* record offset in data file        */
};

#define TIAUDHEADSIZE   14              /* size of struct tiaudhead          */


/*==============================================================================
        tierrio VALUES
==============================================================================*/
#define TIOE_OPEN       0x0010          /* error on open */
#define TIOE_CREA       0x0020          /* error on create */
#define TIOE_SEEK       0x0030          /* error on lseek */
#define TIOE_READ       0x0040          /* error on read */
#define TIOE_WRIT       0x0050          /* error on write */
#define TIOE_LOCK       0x0060          /* error on fcntl */
#define TIOE_IOCTL      0x0070          /* error on ioctl */
#define TIOE_FSTAT      0x0080          /* error on fstat */
#define TIOE_LINK       0x0090          /* error on link */
#define TIOE_CLOSE      0x00a0          /* error on close */

#define TIOE_IDX        0x0001          /* system error on index file */
#define TIOE_DAT        0x0002          /* system error on data file */
#define TIOE_AUD        0x0003          /* system error on audit file */


/*==============================================================================
        tierrno VALUES
==============================================================================*/
#define TIE_DUPL        100             /* duplicate key values not allowed */
#define TIE_NOTOPEN     101             /* file not open */
#define TIE_BADARG      102             /* bad argument */
#define TIE_BADKEY      103             /* bad key descriptor format */
#define TIE_TOOMANY     104             /* too many files open */
#define TIE_BADFILE     105             /* bad file format */
#define TIE_NOTEXCL     106             /* file must be opened exclusive */
#define TIE_LOCKED      107             /* record locked */
#define TIE_KEXISTS     108             /* key descriptor exists */
#define TIE_PRIMKEY     109             /* can't delete primary key */
#define TIE_ENDFILE     110             /* beginning or end of file */
#define TIE_NOREC       111             /* index or key (record) not found */
#define TIE_NOCURR      112             /* currency lost/undefined */
#define TIE_FLOCKED     113             /* file is locked */
#define TIE_FNAME       114             /* file name is too long */
#define TIE_NOLOK       115             /* not used */
#define TIE_BADMEM      116             /* not enough memory */

#define TIE_ALTERTREE   120             /* not used */
#define TIE_OVERRUN     121             /* internal */
#define TIE_REBUILD     123             /* it is necessary to rebuild the file*/
#define TIE_BADIDX      124             /* index file does not match data file*/
#define TIE_FEATURES    125             /* feature mismatch */
#define TIE_FORK        126             /* detected "fork()" with open file */
#define TIE_RECLEN      127             /* invalid record length */
#define TIE_REDEF       128             /* file redefined by other user */


/*==============================================================================
        tierrno MESSAGES
==============================================================================*/
#ifdef  TIDEFSPACE
        int     ti_errbase      = 100;
        int     ti_errtop       = 128;
        char    *ti_errlist[29] = {
                "Duplicate key not allowed",              /* 100 TIE_DUPL     */
                "File not opened",                        /* 101 TIE_NOTOPEN  */
                "Invalid argument",                       /* 102 TIE_BADARG   */
                "Invalid key descriptor format",          /* 103 TIE_BADKEY   */
                "Too many files opened",                  /* 104 TIE_TOOMANY  */
                "Invalid file format",                    /* 105 TIE_BADFILE  */
                "Exclusive access required",              /* 106 TIE_NOTEXCL  */
                "Record locked",                          /* 107 TIE_LOCKED   */
                "Attempt to add key that already exists", /* 108 TIE_KEXISTS  */
                "TISAM version forbids deletion of primary key",
                                                          /* 109 TIE_PRIMKEY  */
                "Beginning or end of file",               /* 110 TIE_ENDFILE  */
                "Index or record not found",              /* 111 TIE_NOREC    */
                "Currency lost or undefined",             /* 112 TIE_NOCURR   */
                "File locked",                            /* 113 TIE_FLOCKED  */
                "File name too long",                     /* 114 TIE_FNAME    */
                "Internal error",                         /* 115 TIE_NOLOK    */
                "No memory available",                    /* 116 TIE_BADMEM   */
                "Unknown error",                          /* 117              */
                "Unknown error",                          /* 118              */
                "Unknown error",                          /* 119              */
                "Unknown error",                          /* 120 TIE_ALTERTREE*/
                "Internal error",                         /* 121 TIE_OVERRUN  */
                "Unknown error",                          /* 122              */
                "Internal error; file must be rebuilt",   /* 123 TIE_REBUILD  */
                "Index file does not match data file",    /* 124 TIE_BADIDX   */
                "File features not understood by this TISAM version",
                                                          /* 125 TIE_FEATURES */
                "Child process using TISAM with files left open by parent",
                                                          /* 126 TIE_FORK     */
                "Record too small to contain keys",       /* 127 TIE_RECLEN   */
                "File redefined by another process"       /* 128 TIE_REDEF    */
        };
#else
        extern int      ti_errbase;
        extern int      ti_errtop;
        extern char     *ti_errlist[];
#endif

#ifndef sys_nerr
        extern int      sys_nerr;
#endif
#ifndef sys_errlist
        extern char     *sys_errlist[];
#endif

/*
 * The macro, tierrmsg, will evaluate to a character string whose value is the
 * message corresponding to an tierrno value returned by a T-ISAM function.
 */
#define tierrmsg ( tierrno==0                ? ""                   : \
                   tierrno>=ti_errbase && tierrno<=ti_errtop          \
                                             ? ti_errlist[tierrno-ti_errbase] :\
                   tierrno<sys_nerr          ? sys_errlist[tierrno] : \
                                               "Unknown error" )

/*==============================================================================
        DEFINE TISAM FUNCTIONS WHICH DO NOT RETURN int VALUES.
==============================================================================*/
        extern long             ldlong();
        extern double           ldfloat();
        extern double           lddbl();

        extern unsigned char    *stint();
        extern unsigned char    *stlong();
        extern unsigned char    *stfloat();
        extern unsigned char    *stdbl();

        extern long             tioption();


/*==============================================================================
        GLOBAL T-ISAM VARIABLES AND DEFAULT/INITIAL VALUES.
==============================================================================*/
#ifdef  TIDEFSPACE
        unsigned long   tiopt           = 0L;   /* default options at build */
        unsigned short  tiflgs          = 0;    /* OR'ed to k_flags */
        unsigned short  tiflge          = 0;    /* OR'ed to k_flage */
        unsigned short  tiflgds         = 0;    /* OR'ed to k_flags if dups */
        unsigned short  tiflgde         = 0;    /* OR'ed to k_flage if dups */
        unsigned int    tinbmx          = 24;   /* desired cache size */

        unsigned int    tireclnr        = 0;    /* data bytes returned */
        unsigned long   tirecid         = 0L;   /* data record offset */
        unsigned long   tinxtid         = 0L;   /* nest data record offset */

        unsigned int    tierrno         = 0;    /* error code */
        unsigned int    tierrio         = 0;    /* I/O error information */
        unsigned char   tistat1         = '0';  /* status byte 1 */
        unsigned char   tistat2         = '0';  /* status byte 2 */

                 char   tivernum[]      = "02.08.8";    /* internal */
        unsigned char   tivchr          = ' ';          /* internal */
        unsigned long   tiodid          = 1024L;        /* internal */
        unsigned long   tixxisam        = 0L;           /* internal */
                 int    (*tiaddx)()     = (int(*)())0;  /* internal */

#else
        extern  unsigned long   tiopt;
        extern  unsigned short  tiflgs;
        extern  unsigned short  tiflge;
        extern  unsigned short  tiflgds;
        extern  unsigned short  tiflgde;
        extern  unsigned int    tinbmx;

        extern  unsigned int    tireclnr;
        extern  unsigned long   tirecid;
        extern  unsigned long   tinxtid;
        extern  unsigned char   tivchr;

        extern  unsigned int    tierrno;
        extern  unsigned int    tierrio;
        extern  unsigned char   tistat1;
        extern  unsigned char   tistat2;

        extern           char   tivernum[];
        extern  unsigned char   tivchr;
        extern  unsigned long   tiodid;
        extern  unsigned long   tixxisam;
        extern  int             (*tiaddx)();

#endif

#define TIMFISAM        0x00000001L     /* internal */
#define TIREISAM        0x00000002L     /* internal */

#endif
tiuser.h
/*      Copyright (c) 1984 AT&T */
/*        All Rights Reserved   */

/*      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T     */
/*      The copyright notice above does not evidence any        */
/*      actual or intended publication of such source code.     */
/*
   COPYRIGHT (c) 1989 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)tiuser.h     1.1 89/12/20";
*/
/*
 * TLI user interface definitions.
 */

#include <sys/tiuser.h>
tp_defs.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)tp_defs.h    1.1 86/05/15";
*/
/*      @(#)tp_defs.h   1.1     */
/*      3.0 SID #       1.1     */
char    mt[]    = "/dev/mt0";
char    tc[]    = "/dev/tapx";
int     flags   = flu;
char    mheader[] = "/usr/mdec/mboot";
char    theader[] = "/usr/mdec/tboot";
unctrl.h
/*      Copyright (c) 1984 AT&T */
/*        All Rights Reserved   */

/*      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T     */
/*      The copyright notice above does not evidence any        */
/*      actual or intended publication of such source code.     */
/*
 * unctrl.h
 *
 */

#ifndef UNCTRL_H
#define UNCTRL_H

extern char     *_unctrl[];

#if     !defined(NOMACROS) && !defined(lint)

#ifndef unctrl
#define unctrl(ch)      (_unctrl[(unsigned) ch])
#endif

#endif  /* NOMACROS && lint */

#endif  /* UNCTRL_H */
unistd.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = "@(#)unistd.h    1.2 (TI) 88/03/08 ";
*/
/*    @(#)unistd.h      1.2    */

#define F_ULOCK 0       /* Unlock a previously locked region */
#define F_LOCK  1       /* Lock a region for exclusive use */
#define F_TLOCK 2       /* Test and lock a region for exclusive use */
#define F_TEST  3       /* Test a region for other processes locks */



/* Symbolic constants for the "access" routine: */
#define R_OK    4       /* Test for Read permission */
#define W_OK    2       /* Test for Write permission */
#define X_OK    1       /* Test for eXecute permission */
#define F_OK    0       /* Test for existence of File */


/* Symbolic constants for the "lseek" routine: */
#define SEEK_SET        0       /* Set file pointer to "offset" */
#define SEEK_CUR        1       /* Set file pointer to current plus "offset" */
#define SEEK_END        2       /* Set file pointer to EOF plus "offset" */

/* Path names: */
#define GF_PATH "/etc/group"    /* Path name of the "group" file */
#define PF_PATH "/etc/passwd"   /* Path name of the "passwd" file */

ustat.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)ustat.h      1.1 86/05/15";
*/
/*      @(#)ustat.h     1.1     */
/*      3.0 SID #       1.1     */
struct  ustat {
        daddr_t f_tfree;        /* total free */
        ino_t   f_tinode;       /* total inodes free */
        char    f_fname[6];     /* filsys name */
        char    f_fpack[6];     /* filsys pack name */
};
utmp.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)utmp.h       1.1 86/05/15";
*/
/*      @(#)utmp.h      1.2     */
/*      @(#)utmp.h      3.2     */

/*      <sys/types.h> must be included.                                 */

#define UTMP_FILE       "/etc/utmp"
#define WTMP_FILE       "/etc/wtmp"
#define ut_name ut_user

struct utmp
  {
        char ut_user[8] ;               /* User login name */
        char ut_id[4] ;                 /* /etc/lines id(usually line #) */
        char ut_line[12] ;              /* device name (console, lnxx) */
        short ut_pid ;                  /* process id */
        short ut_type ;                 /* type of entry */
        struct exit_status
          {
            short e_termination ;       /* Process termination status */
            short e_exit ;              /* Process exit status */
          }
        ut_exit ;                       /* The exit status of a process
                                         * marked as DEAD_PROCESS.
                                         */
        time_t ut_time ;                /* time entry was made */
  } ;

/*      Definitions for ut_type                                         */

#define EMPTY           0
#define RUN_LVL         1
#define BOOT_TIME       2
#define OLD_TIME        3
#define NEW_TIME        4
#define INIT_PROCESS    5       /* Process spawned by "init" */
#define LOGIN_PROCESS   6       /* A "getty" process waiting for login */
#define USER_PROCESS    7       /* A user process */
#define DEAD_PROCESS    8
#define ACCOUNTING      9

#define UTMAXTYPE       ACCOUNTING      /* Largest legal value of ut_type */

/*      Special strings or formats used in the "ut_line" field when     */
/*      accounting for something other than a process.                  */
/*      No string for the ut_line field can be more than 11 chars +     */
/*      a NULL in length.                                               */

#define RUNLVL_MSG      "run-level %c"
#define BOOT_MSG        "system boot"
#define OTIME_MSG       "old time"
#define NTIME_MSG       "new time"
values.h
/* --------------------------------------------------------------------------
   COPYRIGHT (c) 1990   TEXAS INSTRUMENTS INCORPORATED   ALL RIGHTS RESERVED
  --------------------------------------------------------------------------- */

#ident "@(#)values.h    1.5 91/03/19"

#ifndef BITSPERBYTE     /* Check for multiple includes */

/* These values work with any binary representation of integers
 * where the high-order bit contains the sign. */

/* a number used normally for size of a shift */
#if gcos
#define BITSPERBYTE     9
#else
#define BITSPERBYTE     8
#endif

#define BITS(type)      (BITSPERBYTE * (int)sizeof(type))

/* short, regular and long ints with only the high-order bit turned on */
#define HIBITS  ((short)(1 << BITS(short) - 1))
#define HIBITI  (1 << BITS(int) - 1)
#define HIBITL  (1L << BITS(long) - 1)

/* largest short, regular and long int */
#define MAXSHORT        ((short)~HIBITS)
#define MAXINT  (~HIBITI)
#define MAXLONG (~HIBITL)

/* various values that describe the binary floating-point representation
 * _EXPBASE     - the exponent base
 * DMAXEXP      - the maximum exponent of a double (as returned by frexp())
 * FMAXEXP      - the maximum exponent of a float  (as returned by frexp())
 * DMINEXP      - the minimum exponent of a double (as returned by frexp())
 * FMINEXP      - the minimum exponent of a float  (as returned by frexp())
 * MAXDOUBLE    - the largest double
                        ((_EXPBASE ** DMAXEXP) * (1 - (_EXPBASE ** -DSIGNIF)))
 * MAXFLOAT     - the largest float
                        ((_EXPBASE ** FMAXEXP) * (1 - (_EXPBASE ** -FSIGNIF)))
 * MINDOUBLE    - the smallest double (_EXPBASE ** (DMINEXP - 1))
 * MINFLOAT     - the smallest float (_EXPBASE ** (FMINEXP - 1))
 * DSIGNIF      - the number of significant bits in a double
 * FSIGNIF      - the number of significant bits in a float
 * DMAXPOWTWO   - the largest power of two exactly representable as a double
 * FMAXPOWTWO   - the largest power of two exactly representable as a float
 * _IEEE        - 1 if IEEE standard representation is used
 * _DEXPLEN     - the number of bits for the exponent of a double
 * _FEXPLEN     - the number of bits for the exponent of a float
 * _HIDDENBIT   - 1 if high-significance bit of mantissa is implicit
 * LN_MAXDOUBLE - the natural log of the largest double  -- log(MAXDOUBLE)
 * LN_MINDOUBLE - the natural log of the smallest double -- log(MINDOUBLE)
 */

#if defined(u3b) || defined(u3b5)
#define MAXDOUBLE       1.79769313486231470e+308
#define MAXFLOAT        ((float)3.40282346638528860e+38)
#define MINDOUBLE       4.94065645841246544e-324
#define MINFLOAT        ((float)1.40129846432481707e-45)
#define _IEEE           1
#define _DEXPLEN        11
#define _HIDDENBIT      1
#define DMINEXP (-(DMAXEXP + DSIGNIF - _HIDDENBIT - 3))
#define FMINEXP (-(FMAXEXP + FSIGNIF - _HIDDENBIT - 3))
#endif  /* u3b || u3b5 */

#if defined(m68k) || defined(m88k)
/* The following declarations are a kludge to get around the problems
** of cross-compiling float/double constants.  The constant in question
** is the maximum float/double value.  Since the VAX has a smaller range
** than the M68000, it cannot convert MAXFLOAT using the native atof().
** What we do here is to announce external variables whose values
** are set explicitly in an assembly language file.
*/
/* The kludge discussed above has been commented out since it results
   in an SVVS failure.

    extern double _MaXdOuB, _MiNdOuB;
    extern float _MaXfLoA, _MiNfLoA;

#define MAXFLOAT        _MaXfLoA
#define MAXDOUBLE       _MaXdOuB
#define MINFLOAT        _MiNfLoA
#define MINDOUBLE       _MiNdOuB
*/

#define MAXFLOAT        ((float)3.40282346638528860e+38)
#define MAXDOUBLE       ((double)1.79769313486231470e+308)
/* MINFLOAT/MINDOUBLE are defined to give the smallest non-denormalized
** value.
*/
#define MINDOUBLE       ((double)4.4501477170144023e-308)
#define MINFLOAT        ((float)MINDOUBLE)

#define _IEEE           1
#define _DEXPLEN        11
#define _HIDDENBIT      1
#define DMINEXP (-(DMAXEXP) + 1)
#define FMINEXP (-(FMAXEXP) + 1)
#define CUBRTHUGE       6981463519622.333
#define INV_CUBRTHUGE   1.4323644278729908e-13

/* an IEEE std. infinity occurs when exp=max=0x7ff and fractional part == 0 */
#ifdef __GNUC__                 /* GNU C bit fields are different */
#define INF(X) \
((((union {double d; long l[2];} *) &X) -> l[0] & 0x7FFFFFFF) == 0x7FF00000) &&\
 (((union {double d; long l[2];} *) &X) -> l[1] == 0)
#else
#define INF(X) \
(((union { double d; struct { unsigned :1, e:11, f1:20, f2:32; } s; } *)&X)->s.e == 0x7ff) \
&&  \
(((union { double d; struct { unsigned :1, e:11, f1:20, f2:32; } s; } *)&X)->s.f1 == 0) \
&& \
(((union { double d; struct { unsigned :1, e:11, f1:20, f2:32; } s; } *)&X)->s.f2 == 0)
#endif
/* The following detects an infinity and changes it to a large number
   with the correct sign.  The large number is "MAXFLOAT."
   This is consistent with the way "libm" handles overflow,
   but one wonders why it can't be set to MAXDOUBLE instead. */

#define CHNGinf(X)      if (INF(X)) \
                                X = (X>0.0) ? MAXFLOAT : -MAXFLOAT;
#endif  /* m68k */

#if pdp11 || vax
#define MAXDOUBLE       1.701411834604692293e+38
#define MAXFLOAT        ((float)1.701411733192644299e+38)
/* The following is kludged because the PDP-11 compilers botch the simple form.
   The kludge causes the constant to be computed at run-time on the PDP-11,
   even though it is still "folded" at compile-time on the VAX. */
#define MINDOUBLE       (0.01 * 2.938735877055718770e-37)
#define MINFLOAT        ((float)MINDOUBLE)
#define _IEEE           0
#define _DEXPLEN        8
#define _HIDDENBIT      1
#define DMINEXP (-DMAXEXP)
#define FMINEXP (-FMAXEXP)
#endif  /* pdp11 || vax */

#if gcos
#define MAXDOUBLE       1.7014118346046923171e+38
#define MAXFLOAT        ((float)1.7014118219281863150e+38)
#define MINDOUBLE       2.9387358770557187699e-39
#define MINFLOAT        ((float)MINDOUBLE)
#define _IEEE           0
#define _DEXPLEN        8
#define _HIDDENBIT      0
#define DMINEXP (-(DMAXEXP + 1))
#define FMINEXP (-(FMAXEXP + 1))
#endif  /* gcos */

#if u370
#define _LENBASE        4
#else
#define _LENBASE        1
#endif

#define _EXPBASE        (1 << _LENBASE)
#define _FEXPLEN        8
#define DSIGNIF (BITS(double) - _DEXPLEN + _HIDDENBIT - 1)
#define FSIGNIF (BITS(float)  - _FEXPLEN + _HIDDENBIT - 1)

#if m68k || m88k        /* different because BITS(long) > DSIGNIF */
/***TEMP #define        DMAXPOWTWO      ((double)(1L << DSIGNIF - 1)) */
#define DMAXPOWTWO      ((double)(1L << BITS(long) - 2) * \
                                (1L << DSIGNIF - BITS(long) + 1))
#else
#define DMAXPOWTWO      ((double)(1L << BITS(long) - 2) * \
                                (1L << DSIGNIF - BITS(long) + 1))
#endif

#define FMAXPOWTWO      ((float)(1L << FSIGNIF - 1))
#define DMAXEXP ((1 << _DEXPLEN - 1) - 1 + _IEEE)
#define FMAXEXP ((1 << _FEXPLEN - 1) - 1 + _IEEE)
#define LN_MAXDOUBLE    (M_LN2 * DMAXEXP)
#define LN_MINDOUBLE    (M_LN2 * (DMINEXP - 1))
#define H_PREC  (DSIGNIF % 2 ? (1L << DSIGNIF/2) * M_SQRT2 : 1L << DSIGNIF/2)
#define X_EPS   (1.0/H_PREC)
#define X_PLOSS ((double)(long)(M_PI * H_PREC))
#define X_TLOSS (M_PI * DMAXPOWTWO)
#define M_LN2   0.69314718055994530942
#define M_PI    3.14159265358979323846
#define M_SQRT2 1.41421356237309504880
#define MAXBEXP DMAXEXP /* for backward compatibility */
#define MINBEXP DMINEXP /* for backward compatibility */
#define MAXPOWTWO       DMAXPOWTWO /* for backward compatibility */

#endif  /* BITSPERBYTE */

varargs.h
/*
   COPYRIGHT (c) 1986 TEXAS INSTRUMENTS, INCORPORATED.  ALL RIGHTS RESERVED.
*/
/*
static char *sccs_id = @(#)varargs.h    1.1 86/05/15";
*/
/*      @(#)varargs.h   1.2     */
typedef char *va_list;
#define va_dcl int va_alist;
#define va_start(list) list = (char *) &va_alist
#define va_end(list)
#ifdef u370
#define va_arg(list, mode) ((mode *)(list = \
        (char *) ((int)list + 2*sizeof(mode) - 1 & -sizeof(mode))))[-1]
#else
#define va_arg(list, mode) ((mode *)(list += sizeof(mode)))[-1]
#endif
vdtrdwrt.h
/*
        (C) COPYRIGHT, TEXAS INSTRUMENTS INCORPORATED, 1991.  ALL
        RIGHTS RESERVED.  PROPERTY OF TEXAS INSTRUMENTS INCORPORATED.
        RESTRICTED RIGHTS - USE, DUPLICATION, OR DISCLOSURE IS SUBJECT
        TO RESTRICTIONS SET FORTH IN TI'S PROGRAM LICENSE AGREEMENT AND
        ASSOCIATED DOCUMENTATION.

*/

/*
********************************************************************************
*               Copyright (c) 1984 AT&T Technologies, Inc.                     *
*                           All Rights Reserved                                *
*                                                                              *
*                                                                              *
*             THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF                   *
*                         AT&T TECHNOLOGIES, INC.                              *
*        The copyright notice above does not evidence any actual               *
*        or intended publication of such source code.                          *
********************************************************************************
*/
#ident "@(#)vdtrdwrt.h  1.14 91/01/04"
/* contains structures used in application interface to field edit      */

/* opcodes       */
/* these opcodes are used by the application, vdtread/write routines, and */
/* field edit routines in the driver.  Nubus transport uses the ioctl opcodes */
/* defined in busnet.h.  Crb opcodes used by driver lower levels are defined */
/* in c304.h.                                                              */
#define FEWRITE         0x01            /* field edit write  */
#define STSWRITE        0x02            /* status line write */
#define STSRSTOR        0x03            /* status line restore */
#define FEREAD          0x04            /* field edit read     */
#define UPDATE          0x05            /* read with initial value */
#define UPDATE1         0x06            /* update w/o display */

/* validation table describes which characters are valid or invalid */
struct vpair {
        unsigned char low ;     /* low character in range  */
        unsigned char hi ;      /* high character in range */
} ;
struct validtable {
        short length ;  /* total length of table   */
        short flags ;   /* are following ranges valid or invalid? */
        struct vpair range[128] ;       /* up to 128 ranges    */
} ;

/* readblock describes how a read is to be done  */
struct readblock {
        char  opcode ;          /* either read or update, so far */
        long fldflags;          /* which field edit keys to honor  */
        short  miscflag;        /* misc options */
        unsigned char sgr_on, sgr_off;          /* sgr flags */
        unsigned char fg_color, bg_color;       /* color specification */
        unsigned char  *buffaddr ;      /* read buffer pointer          */
        short bufflen ;         /* number of characters to read  */
        unsigned char  fieldrow ;       /* field start row address */
        unsigned char  fieldcol ;       /* field start column address */
        unsigned char  cursorrow ;      /* starting cursor row position */
        unsigned char  cursorcol ;      /* starting cursor column position */
        short rtimeout ;        /* request timeout    */
        char  prompt ;          /* prompt character  */
        char  fill ;            /* fill character  */
        long   eventflags1 ;    /* which of 32 function keys to honor */
        long   eventflags2 ;    /* which events to honor    */
        long    eventflags3;    /* function keys 33-64 */
        long    eventflags4;    /* function keys 65-96 */
        long    eventflags5;    /* function keys 97-128 */
        struct ccbread *rtrn ;  /* pointer to returned data */
        struct validtable *valid_table_addr ; /* validation table offset */
} ;
/* on return to application from read request, readblock pointer points to */
/* a ccbread structure, which contains read data and last cursor position  */
struct ccbread {
        long   eventflag1 ;     /* event/function keys, unchanged */
        long   eventflag2 ;
        long    eventflag3;
        long    eventflag4;
        long    eventflag5;
        int   fldflg ;          /* field edit keys to honor             */
        unsigned char *buffaddr;/* pointer to returned read data        */
        short bufflen ;         /* number of characters actually read   */
        short vtabladdr ;       /* offset to start of validation table  */
        short miscflag ;        /* misc options, unchanged              */
        char  opcode ;          /* read or update, unchanged            */
        char  prompt ;          /* prompt character, unchanged          */
        char  fill ;            /* fill character, unchanged            */
        unsigned char  frow ;   /* field start row position, unchanged  */
        unsigned char  fcol ;   /* field start col position, unchanged  */
        unsigned char  crow ;   /* final cursor row position            */
        unsigned char  ccol ;   /* final cursor col position            */
        unsigned char  numevents ;/* number of events of same type      */
        short pad ;             /* unused, reserved for future          */
} ;
/* writeblock describes how each field in a request is to be written */
struct writeblock {
        char  opcode ;  /* write, write status line, restore status line */
        char  error ;   /* mostly syntax errors in block */
        short  miscflag;        /* misc options */
        unsigned char sgr_on, sgr_off;          /* sgr flags */
        unsigned char fg_color, bg_color;       /* color specification */
        unsigned char *buffaddr ;/* data buffer pointer  */
        short bufflen ; /* length of data to write, this field  */
        unsigned char  row ;    /* row address to start writing */
        unsigned char col ;     /* column address to start writing */
        struct writeblock *nextblockaddr ; /* link to next field descriptor */
} ;

struct  sFE_get_parms {
        unsigned char max_row,max_col;
};

struct attributes {
        unsigned char disp ;
        unsigned char fg_color ;
        unsigned char bg_color ;
        unsigned char res ;
} ;

struct FE_screen {
        unsigned char maxrow ;
        unsigned char maxcol ;
        short         flags ;
        unsigned char *data ;
        struct attributes *attr ;
} ;

/* eventflags1 flag definitions - which function keys to honor (1-32) */
#define FED_F1KEY ((long)1<<0)
#define FED_F2KEY ((long)1<<1)
#define FED_F3KEY ((long)1<<2)
#define FED_F4KEY ((long)1<<3)
#define FED_F5KEY ((long)1<<4)
#define FED_F6KEY ((long)1<<5)
#define FED_F7KEY ((long)1<<6)
#define FED_F8KEY ((long)1<<7)
#define FED_F9KEY ((long)1<<8)
#define FED_F10KEY ((long)1<<9)
#define FED_F11KEY ((long)1<<10)
#define FED_F12KEY ((long)1<<11)
#define FED_F13KEY ((long)1<<12)
#define FED_F14KEY ((long)1<<13)
#define FED_F15KEY ((long)1<<14)
#define FED_F16KEY ((long)1<<15)
#define FED_F17KEY ((long)1<<16)
#define FED_F18KEY ((long)1<<17)
#define FED_F19KEY ((long)1<<18)
#define FED_F20KEY ((long)1<<19)
#define FED_F21KEY ((long)1<<20)
#define FED_F22KEY ((long)1<<21)
#define FED_F23KEY ((long)1<<22)
#define FED_F24KEY ((long)1<<23)
#define FED_F25KEY ((long)1<<24)
#define FED_F26KEY ((long)1<<25)
#define FED_F27KEY ((long)1<<26)
#define FED_F28KEY ((long)1<<27)
#define FED_F29KEY ((long)1<<28)
#define FED_F30KEY ((long)1<<29)
#define FED_F31KEY ((long)1<<30)
#define FED_F32KEY ((long)1<<31)
/* eventflags3 flag definitions - which function keys to honor (33-64) */
#define FED_F33KEY ((long)1<<0)
#define FED_F34KEY ((long)1<<1)
#define FED_F35KEY ((long)1<<2)
#define FED_F36KEY ((long)1<<3)
#define FED_F37KEY ((long)1<<4)
#define FED_F38KEY ((long)1<<5)
#define FED_F39KEY ((long)1<<6)
#define FED_F40KEY ((long)1<<7)
#define FED_F41KEY ((long)1<<8)
#define FED_F42KEY ((long)1<<9)
#define FED_F43KEY ((long)1<<10)
#define FED_F44KEY ((long)1<<11)
#define FED_F45KEY ((long)1<<12)
#define FED_F46KEY ((long)1<<13)
#define FED_F47KEY ((long)1<<14)
#define FED_F48KEY ((long)1<<15)
#define FED_F49KEY ((long)1<<16)
#define FED_F50KEY ((long)1<<17)
#define FED_F51KEY ((long)1<<18)
#define FED_F52KEY ((long)1<<19)
#define FED_F53KEY ((long)1<<20)
#define FED_F54KEY ((long)1<<21)
#define FED_F55KEY ((long)1<<22)
#define FED_F56KEY ((long)1<<23)
#define FED_F57KEY ((long)1<<24)
#define FED_F58KEY ((long)1<<25)
#define FED_F59KEY ((long)1<<26)
#define FED_F60KEY ((long)1<<27)
#define FED_F61KEY ((long)1<<28)
#define FED_F62KEY ((long)1<<29)
#define FED_F63KEY ((long)1<<30)
#define FED_F64KEY ((long)1<<31)
/* eventflags4 flag definitions - which function keys to honor (65-96) */
#define FED_F65KEY ((long)1<<0)
#define FED_F66KEY ((long)1<<1)
#define FED_F67KEY ((long)1<<2)
#define FED_F68KEY ((long)1<<3)
#define FED_F69KEY ((long)1<<4)
#define FED_F70KEY ((long)1<<5)
#define FED_F71KEY ((long)1<<6)
#define FED_F72KEY ((long)1<<7)
#define FED_F73KEY ((long)1<<8)
#define FED_F74KEY ((long)1<<9)
#define FED_F75KEY ((long)1<<10)
#define FED_F76KEY ((long)1<<11)
#define FED_F77KEY ((long)1<<12)
#define FED_F78KEY ((long)1<<13)
#define FED_F79KEY ((long)1<<14)
#define FED_F80KEY ((long)1<<15)
#define FED_F81KEY ((long)1<<16)
#define FED_F82KEY ((long)1<<17)
#define FED_F83KEY ((long)1<<18)
#define FED_F84KEY ((long)1<<19)
#define FED_F85KEY ((long)1<<20)
#define FED_F86KEY ((long)1<<21)
#define FED_F87KEY ((long)1<<22)
#define FED_F88KEY ((long)1<<23)
#define FED_F89KEY ((long)1<<24)
#define FED_F90KEY ((long)1<<25)
#define FED_F91KEY ((long)1<<26)
#define FED_F92KEY ((long)1<<27)
#define FED_F93KEY ((long)1<<28)
#define FED_F94KEY ((long)1<<29)
#define FED_F95KEY ((long)1<<30)
#define FED_F96KEY ((long)1<<31)
/* eventflags5 flag definitions - which function keys to honor (97-128) */
#define FED_F97KEY ((long)1<<0)
#define FED_F98KEY ((long)1<<1)
#define FED_F99KEY ((long)1<<2)
#define FED_F100KEY ((long)1<<3)
#define FED_F101KEY ((long)1<<4)
#define FED_F102KEY ((long)1<<5)
#define FED_F103KEY ((long)1<<6)
#define FED_F104KEY ((long)1<<7)
#define FED_F105KEY ((long)1<<8)
#define FED_F106KEY ((long)1<<9)
#define FED_F107KEY ((long)1<<10)
#define FED_F108KEY ((long)1<<11)
#define FED_F109KEY ((long)1<<12)
#define FED_F110KEY ((long)1<<13)
#define FED_F111KEY ((long)1<<14)
#define FED_F112KEY ((long)1<<15)
#define FED_F113KEY ((long)1<<16)
#define FED_F114KEY ((long)1<<17)
#define FED_F115KEY ((long)1<<18)
#define FED_F116KEY ((long)1<<19)
#define FED_F117KEY ((long)1<<20)
#define FED_F118KEY ((long)1<<21)
#define FED_F119KEY ((long)1<<22)
#define FED_F120KEY ((long)1<<23)
#define FED_F121KEY ((long)1<<24)
#define FED_F122KEY ((long)1<<25)
#define FED_F123KEY ((long)1<<26)
#define FED_F124KEY ((long)1<<27)
#define FED_F125KEY ((long)1<<28)
#define FED_F126KEY ((long)1<<29)
#define FED_F127KEY ((long)1<<30)
#define FED_F128KEY ((long)1<<31)
/* eventflags2 bit definitions - which event keys to honor */
#define FED_PRINT_SCREEN 0x00000001
#define FED_REDRAW_SCREEN 0x00000002
#define FED_BAKSPAC     0x00000040
#define FED_UPARROW     0x00000080
#define FED_DNARROW     0x00000100
#define FED_LFARROW     0x00000200
#define FED_RTARROW     0x00000400
#define FED_INSCHAR     0x00000800
#define FED_DELCHAR     0x00001000
#define FED_ERASFLD     0x00002000
#define FED_SKIPKEY     0x00004000
#define FED_HOMEKEY     0x00010000
#define FED_ESCKEY      0x00020000
#define FED_PRINTKEY    0x00040000
#define FED_ERASINPUT   0x00080000
#define FED_ENTER       0x00100000
#define FED_BLNKGREY    0x02000000
#define FED_CMDKEY      0x04000000
#define FED_LFTFLD      0x08000000
#define FED_RITFLD      0x10000000
#define FED_BAKTAB      0x20000000
#define FED_TABKEY      0x40000000
#define FED_RTRNKEY     0x80000000

/* field flags bit definitions: if set, specified key is honored */
#define FED_EVENTREQ    0x00000001 /* only event key terminates read */
#define FED_MDT         0x00000002 /* modified data tag              */
#define FED_NOECHO      0x00000004 /* do not echo read data          */
#define FED_MULTIVENT   0x00000008 /* accept multiple events         */
#define FED_OVERTYPE    0x00000010 /* allow overtype on field full   */
#define FED_BS_DESTRUCT 0x00000020 /* backspace is destructive       */
#define FED_SKIPF       0x00000040 /* honor skip function            */
#define FED_ERASFLDF    0x00000080 /* honor erase field function     */
#define FED_DELCHARF    0x00000100 /* honor delete char function     */
#define FED_INSCHARF    0x00000200 /* honor insert char function     */
#define FED_BSCHARF     0x00000400 /* honor backspace function       */
#define FED_CURHOMEF    0x00000800 /* honor home cursor function     */
#define FED_DWNAROWF    0x00001000 /* down arrow function            */
#define FED_UPAROWF     0x00002000 /* up arrow function              */
#define FED_RIGHTAROWF  0x00004000 /* right arrow key                */
#define FED_LEFTAROWF   0x00008000 /* left arrow key                 */
#define FED_RTMARGIN    0x00010000 /* limit INS/DEL to right margin  */
#define FED_INSRTMOD    0x00020000 /* don't even ask!!               */
#define FED_SKIPLAST    0x00040000 /* skip does not delete last char */
                                   /* in a full field.               */

/* miscellaneous flags definitions:  describes misc options read/write */
#define FED_ERASEOS     0x0200  /* erase to end of screen  */
#define FED_ERASEOL     0x0400  /* erase to end of line  */
#define FED_BEEP        0x0800  /* honk the horn      */
#define FED_SOLIDC      0x4000  /* make cursor solid  */
#define FED_BLINKC      0x8000  /* blink the cursor */
#define FED_ESMASK      0x0600  /* erase screen mask */
#define FED_SCROLL      0x0001  /* Scroll display */

/* SGR flags definitions:  describes SGR options read/write */
#define FED_SGR_ENABLE  0x80    /* SGR change requested */
#define FED_SGR_MASK    0xf     /* mask to extract sgr bits */
#define FED_BLINKF      8       /* blink the field  */
#define FED_UNDRLINE    4       /* underline the data displayed */
#define FED_REVERSE     2       /* display in reverse video */
#define FED_HIGHINT     1       /* display in high intensity */
/*
        The following macro's can be used to set the sgr bits to the
        proper values in order to set the sgr to only those bits that
        are specified.
*/
#define set_rd_sgr(a,b) (((struct readblock *)a)->sgr_on = FED_SGR_ENABLE+b),\
        (((struct readblock *)a)->sgr_off = FED_SGR_ENABLE + (FED_SGR_MASK & ~b))
#define set_wrt_sgr(a,b) (((struct writeblock *)a)->sgr_on = FED_SGR_ENABLE+b),\
        (((struct writeblock *)a)->sgr_off = FED_SGR_ENABLE + (FED_SGR_MASK & ~b))

/* Color flag definitions: Used to specify color (if supported) */
#define FED_COLOR_ENABLE 0x80   /* color change requested */
typedef enum {BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE} color_enum;

/* validation table flag:  if set, table specifies invalid characters */
#define VALID           0x00    /* only chars in range are valid */
#define NVALID          0x01    /* chars in ranges are invalid */
#define ALTABLE         0x02    /* use alternate bitmap table */
#define EVENT_CHAR_BIAS 0x1000  /* bias used to report char events */

struct alttable {
        short length ;
        short flags ;
        unsigned long bitmap[16] ;
} ;
#define VBITS_IGNORE 0
#define VBITS_EVENT 1
#define VBITS_DATA 2

/* FE_open parameter flag definitions */
typedef enum {no_sgr_opt,
                no_cursor_opt,
                no_buf_wrts,
                no_raw_wrts,
                sticky_margin,
                nodisplay_cursor,
                noscroll_image,
                scrnimage,
                last_flag} flag_pos;

/* mapped event key return value:  if an event key is pressed, and the */
/* flags specify that it is to be honored in this request, the read    */
/* terminates and the corresponding value is returned                  */
#define FED_PRINTSCR_EVENT 0x01 /* returned only if screen image is not */
#define FED_REDRAWSCR_EVENT 0x02 /* being kept by field edit library    */
#define FED_F1EVENT     0x81
#define FED_F2EVENT     0x82
#define FED_F3EVENT     0x83
#define FED_F4EVENT     0x84
#define FED_F5EVENT     0x85
#define FED_F6EVENT     0x86
#define FED_F7EVENT     0x96
#define FED_F8EVENT     0x97
#define FED_F9EVENT     0x80
#define FED_F10EVENT    0x9a
#define FED_F11EVENT    0x9c
#define FED_F12EVENT    0x9d
#define FED_F13EVENT    0x9e
#define FED_F14EVENT    0x9f
#define FED_F15EVENT    0xe0
#define FED_F16EVENT    0xe1
#define FED_F17EVENT    0xe2
#define FED_F18EVENT    0xe3
#define FED_F19EVENT    0xe4
#define FED_F20EVENT    0xe5
#define FED_F21EVENT    0xe6
#define FED_F22EVENT    0xe7
#define FED_F23EVENT    0xe8
#define FED_F24EVENT    0xe9
#define FED_ENTREVENT   0x93    /* event from enter key  */
#define FED_CMDEVENT    0x98    /* event from command key */
#define FED_PRTEVENT    0x99    /* event from print key  */
#define FED_RTRNEVENT   0x8d    /* event from return key */
#define FED_ARUPEVENT   0x95    /* event from up arrow */
#define FED_ARDNEVENT   0x8a    /* event from down arrow */
#define FED_ARLFEVENT   0x88    /* event from left arrow */
#define FED_ARRTEVENT   0x92    /* event from right arrow */
#define FED_RTFLDEVENT  0x87    /* event from right field key */
#define FED_LTFLDEVENT  0x94    /* event from left field key */
#define FED_TABEVENT    0x89    /* event from tab key */
#define FED_BKTABEVENT  0xef    /* event from back tab key */
#define FED_BGREYEVENT  0x8f    /* event from blank grey key */
#define FED_ERNPTEVENT  0x8e    /* event from erase input key */
#define FED_SKIPEVENT   0x8b    /* event from skip key */
#define FED_ESCEVENT    0x9b    /* event from shifted escape key */
#define FED_HOMEVENT    0x8c    /* event from home key */
#define FED_ERSFLDEVENT 0x7f    /* event from erase field key */
#define FED_DELCHREVENT 0x90    /* event from delete char key */
#define FED_INSCHREVENT 0x91    /* event from insert char key */
#define FED_BAKSPEVENT  0xdf    /* event from backaspace key  */

#define FED_F25EVENT (0xf0 + 0)
#define FED_F26EVENT (0xf0 + 1)
#define FED_F27EVENT (0xf0 + 2)
#define FED_F28EVENT (0xf0 + 3)
#define FED_F29EVENT (0xf0 + 4)
#define FED_F30EVENT (0xf0 + 5)
#define FED_F31EVENT (0xf0 + 6)
#define FED_F32EVENT (0xf0 + 7)
#define FED_F33EVENT (0xf0 + 8)
#define FED_F34EVENT (0xf0 + 9)
#define FED_F35EVENT (0xf0 + 10)
#define FED_F36EVENT (0xf0 + 11)
#define FED_F37EVENT (0xf0 + 12)
#define FED_F38EVENT (0xf0 + 13)
#define FED_F39EVENT (0xf0 + 14)
#define FED_F40EVENT (0xf0 + 15)
#define FED_F41EVENT (0xf0 + 16)
#define FED_F42EVENT (0xf0 + 17)
#define FED_F43EVENT (0xf0 + 18)
#define FED_F44EVENT (0xf0 + 19)
#define FED_F45EVENT (0xf0 + 20)
#define FED_F46EVENT (0xf0 + 21)
#define FED_F47EVENT (0xf0 + 22)
#define FED_F48EVENT (0xf0 + 23)
#define FED_F49EVENT (0xf0 + 24)
#define FED_F50EVENT (0xf0 + 25)
#define FED_F51EVENT (0xf0 + 26)
#define FED_F52EVENT (0xf0 + 27)
#define FED_F53EVENT (0xf0 + 28)
#define FED_F54EVENT (0xf0 + 29)
#define FED_F55EVENT (0xf0 + 30)
#define FED_F56EVENT (0xf0 + 31)
#define FED_F57EVENT (0xf0 + 32)
#define FED_F58EVENT (0xf0 + 33)
#define FED_F59EVENT (0xf0 + 34)
#define FED_F60EVENT (0xf0 + 35)
#define FED_F61EVENT (0xf0 + 36)
#define FED_F62EVENT (0xf0 + 37)
#define FED_F63EVENT (0xf0 + 38)
#define FED_F64EVENT (0xf0 + 39)
#define FED_F65EVENT (0xf0 + 40)
#define FED_F66EVENT (0xf0 + 41)
#define FED_F67EVENT (0xf0 + 42)
#define FED_F68EVENT (0xf0 + 43)
#define FED_F69EVENT (0xf0 + 44)
#define FED_F70EVENT (0xf0 + 45)
#define FED_F71EVENT (0xf0 + 46)
#define FED_F72EVENT (0xf0 + 47)
#define FED_F73EVENT (0xf0 + 48)
#define FED_F74EVENT (0xf0 + 49)
#define FED_F75EVENT (0xf0 + 50)
#define FED_F76EVENT (0xf0 + 51)
#define FED_F77EVENT (0xf0 + 52)
#define FED_F78EVENT (0xf0 + 53)
#define FED_F79EVENT (0xf0 + 54)
#define FED_F80EVENT (0xf0 + 55)
#define FED_F81EVENT (0xf0 + 56)
#define FED_F82EVENT (0xf0 + 57)
#define FED_F83EVENT (0xf0 + 58)
#define FED_F84EVENT (0xf0 + 59)
#define FED_F85EVENT (0xf0 + 60)
#define FED_F86EVENT (0xf0 + 61)
#define FED_F87EVENT (0xf0 + 62)
#define FED_F88EVENT (0xf0 + 63)
#define FED_F89EVENT (0xf0 + 64)
#define FED_F90EVENT (0xf0 + 65)
#define FED_F91EVENT (0xf0 + 66)
#define FED_F92EVENT (0xf0 + 67)
#define FED_F93EVENT (0xf0 + 68)
#define FED_F94EVENT (0xf0 + 69)
#define FED_F95EVENT (0xf0 + 70)
#define FED_F96EVENT (0xf0 + 71)
#define FED_F97EVENT (0xf0 + 72)
#define FED_F98EVENT (0xf0 + 73)
#define FED_F99EVENT (0xf0 + 74)
#define FED_F100EVENT (0xf0 + 75)
#define FED_F101EVENT (0xf0 + 76)
#define FED_F102EVENT (0xf0 + 77)
#define FED_F103EVENT (0xf0 + 78)
#define FED_F104EVENT (0xf0 + 79)
#define FED_F105EVENT (0xf0 + 80)
#define FED_F106EVENT (0xf0 + 81)
#define FED_F107EVENT (0xf0 + 82)
#define FED_F108EVENT (0xf0 + 83)
#define FED_F109EVENT (0xf0 + 84)
#define FED_F110EVENT (0xf0 + 85)
#define FED_F111EVENT (0xf0 + 86)
#define FED_F112EVENT (0xf0 + 87)
#define FED_F113EVENT (0xf0 + 88)
#define FED_F114EVENT (0xf0 + 89)
#define FED_F115EVENT (0xf0 + 90)
#define FED_F116EVENT (0xf0 + 91)
#define FED_F117EVENT (0xf0 + 92)
#define FED_F118EVENT (0xf0 + 93)
#define FED_F119EVENT (0xf0 + 94)
#define FED_F120EVENT (0xf0 + 95)
#define FED_F121EVENT (0xf0 + 96)
#define FED_F122EVENT (0xf0 + 97)
#define FED_F123EVENT (0xf0 + 98)
#define FED_F124EVENT (0xf0 + 99)
#define FED_F125EVENT (0xf0 + 100)
#define FED_F126EVENT (0xf0 + 101)
#define FED_F127EVENT (0xf0 + 102)
#define FED_F128EVENT (0xf0 + 103)

/* FE_abort flags definitions */
#define ABORT_READ      1
#define ABORT_WRITE     2
#define ABORT_OPEN      4
#define ABORT_CLOSE     8

/*                                                                        */
/**************************************************************************/
/*                 CCB and Field edit errors                              */
/*      ********************  WARNING  *****************************      */
/*      These error symbols and numbers may be removed in a future        */
/*      release of field edit. The error symbols following these will be  */
/*      the replacement symbols and error numbers. It is recommended that */
/*      those symbols be used.                                            */
/**************************************************************************/
/*                                                                        */
/* These symbols are commented out and here for reference to the original */
/* names.  You should be using names of the following set of symbols.     */
/*
#define      EBADFD             50
#define      ENOFETBL           51
#define      EBADBLOCK          52
#define      EBADOP             53
#define      EBADBUFF           54
#define      EBADLEN            55
#define      EBADCURS           56
#define      EFLGERR            57
#define      EVTABLE            58
#define      EBADCNT            59
#define      ERDTMO             60
#define      EFELIB_DATED       61
#define      ECCB_DATED         62
#define      ENOIMAGE           63
*** END of commented out symbol names   */
/*                                                                        */
/**************************************************************************/
/*                                                                        */
/* New ccb and field edit errors                                          */
/*                                                                        */
/**************************************************************************/
/*                                                                        */
#define EFE_BADFD       50      /* invalid FD specified */
#define EFE_NOFETBL     51      /* no Field edit table avail. */
#define EFE_BADBLOCK    52      /* invalid field edit read block        */
#define EFE_BADOP       53      /* invalid field edit opcode            */
#define EFE_BADBUFF     54      /* field edit buffer address error      */
#define EFE_BADLEN      55      /* field edit buffer length error       */
#define EFE_BADCURS     56      /* cursor positioning error             */
#define EFE_FLGERR      57      /* field edit event flag error          */
#define EFE_VTABLE      58      /* validation table error               */
#define EFE_BADCNT      59      /* wrtblk count not consistant with linkage */
#define EFE_RDTMO       60      /* read timeout period elapsed */
#define EFE_FELIB_DATED 61      /* felib code older version than ccb code */
#define EFE_CCB_DATED   62      /* ccb code older version than felib code */
#define EFE_NOIMAGE     63      /* screen image not being kept  */
x25lib.h
xns.h
/*
        (C) COPYRIGHT, TEXAS INSTRUMENTS INCORPORATED, 1985.  ALL
        RIGHTS RESERVED.  PROPERTY OF TEXAS INSTRUMENTS INCORPORATED.
        RESTRICTED RIGHTS - USE, DUPLICATION, OR DISCLOSURE IS SUBJECT
        TO RESTRICTIONS SET FORTH IN TI'S PROGRAM LICENSE AGREEMENT AND
        ASSOCIATED DOCUMENTATION.
 */
/* @(#)xns.h    1.2 87/08/20 */

union  addr48 {                 /* definition of 48-bit address */
        char    adr[6];
        unsigned short sadr[3];
};

/* IDP header structure */
struct s_idphdr {               /* XNS internet datagram protocol */
    short    idpcheck;          /* checksum */
    short    idplen;            /* total length of IDP packet */
    char     idpxport;          /* transport control */
    char     idptype;           /* type of XNS level 2 packet */
    long     idpdnet;           /* destination network id */
    short    idpdhost[3];       /* destination 48-bit host address */
    short    idpdskt;           /* destination socket number */
    long     idpsnet;           /* source network id */
    short    idpshost[3];       /* source 48-bit host address */
    short    idpsskt;           /* source socket number */
};

struct s_pephdr {
    long     pepxid;            /* transaction id */
    short    pepcltype;         /* client type */
};
#define PEPHDRLEN       (sizeof(struct s_pephdr))

#define RIP_TYPE        1
#define ECHO_TYPE       2
#define ERROR_TYPE      3
#define PEP_TYPE        4
#define SPP_TYPE        5

struct  sOP_read {
        int     handle;         /* suppiled handle */
        unsigned int    timout; /* how long to wait (250msec units) */
};

#define NUM_MREAD  8
struct  sOP_mread {
        int     numhandles;
        int     handles[NUM_MREAD];     /* array of handles */
        unsigned int    timout; /* how long to wait (250msec units) */
};

struct  sOP_write {             /* MUST be same size as sOP_read */
        int     filler[2];
};

struct  sOP_pep {
        int reqlength;
        int rspoff;             /* offset to response area */
        short retries;
        short timo;
};

struct  sOP_rm {
        unsigned long rmnet;
        unsigned short rmhost[3];
        char resname[8];
        unsigned short actlen;
};

struct  sOP_rout {
        int numnets;
        int curtics;
        int gateflags;
};

struct  sOP_malloc {
         int  numskts;
};

#define NS_OK           0
#define NS_IOERR        1003920
#define NS_NOSOCKAVAIL  1003921
#define NS_SOCKTBLFULL  1003922
#define NS_INVSKT       1003923
#define NS_INUSE        1003924
#define NS_OPENTBLFULL  1003925
#define NS_NOTALLOC     1003926
#define NS_NOTOPEN      1003927
#define NS_UNKNET       1003928
#define NS_BADHAND      1003929
#define NS_READPEND     1003930
#define NS_XFRFAIL      1003931
#define NS_TRUNCATION   1003932
#define NS_TOOBIG       1003933
#define NS_TIMOUT       1003934
#define NS_RESERR       1003935
#define NS_BADOP        1003936
#define NS_ALRDYOPEN    1003937
#define NS_DUPRSRC      1003938
#define NS_UNDEFRSRC    1003939
#define NS_POSTTBLFULL  1003940
#define NS_BADIDPSIZE   1003941
#define NS_SIZEERR      1003942
#define NS_UNREGRSRC    1003943
#define NS_BADREQ       1003944

struct  sioctl_head {           /* ioctl fixed header */
        int     size;                   /* size of ioctl buf */
        int     op_code;                /* supplied op_code */
        int     status;                 /* returned status */
        int     socket;                 /* supplied/returned socket */
};

struct s_idpioctl {
        struct sioctl_head ioctl_head;
        union {
            struct sOP_read opread;
            struct sOP_write opwrite;
        } rwcmd;
};

struct s_pepioctl {
        struct sioctl_head ioctl_head;
        struct sOP_pep oppep;
};

struct s_routent {
        unsigned long netnum;           /* network number */
        unsigned short router[3];       /* 48-bit address of router */
        unsigned char hop;              /* hop count (0 means local) */
        unsigned char port;             /* LAN port used for routing */
        unsigned long uptime;           /* last update time */
};

struct s_rmioctl {
        struct sioctl_head ioctl_head;
        struct sOP_rm oprm;
};

struct s_routioctl {
        struct sioctl_head ioctl_head;
        struct sOP_rout oprout;
};

struct  sRMhdr {                        /* rm header */
    char                RMhisname[8];   /* requested resource name */
    char                RMmyname[8];    /* requestor's name */
    unsigned short      RMopcode;       /* rm opcode */
    unsigned short      RMstat;         /* rm status */
    unsigned long       RMnet;          /* requested resource network */
    union       addr48  RMhost;         /* requested resource host */
    unsigned short      RMsock;         /* requested resource socket */
    unsigned short      RMtype;         /* requestor's data type */
    long                RMtrnid;        /* requestor's transaction id */
};
#
